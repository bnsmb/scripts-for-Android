#
#
#
# include file for ${0##*/}.sh
#
# This file contains tasks to install and configure phones running the Android OS
# 
# This is an include file for the script execute_tasks.sh 
#
# execute_tasks.sh can be downloaded here: https://bnsmb.de/files/public/solaris/scripts/execute_tasks.sh
#
# a description how to use this file is here: http://bnsmb.de/My_HowTos_for_Android.html#How_to_install_and_configure_the_Android
#
# ---------------------------------------------------------------------
# Important:
# 
# If you get an useless error message like this
#
# ./prepare_phone.sh[6474]: init_tasks[2170]: typeset: : invalid variable name
#
# most probably the include file is too large for your current environment -- either free some memory or remove (comment) lines from this file
# ---------------------------------------------------------------------
#
#
# debug code
#
# This code will be executed at every start of a function - the code should NOT write something to STDOUT!
#
# __FUNCTION_INIT='eval echo "**** ${__FUNCTION}: TWRP_IMAGE is \"${TWRP_IMAGE}\" " >&2  '


# enable single step on error for executing the tasks
#
ENABLE_SINGLE_STEP_ON_ERROR=${__TRUE}


#H# History
#H#
#H#  27.01.2023 /bs 
#H#     initial release
#H#
#H#  28.01.2023 /bs 
#H#    the tasks enable_root_access_for_the_shell install_the magisk_app, install_apps, 
#H#      install_essential_apps, and enable_root_access_for_the_shell did not work if more then one phone was connected -- fixed
#H#    
#H#  15.04.2023 /bs
#H#     added the task install_magisk_v26_in_boot_partition to install Magisk v26 or newer
#H#    
#H#  06.05.2023 /bs
#H#     the task install_os ended with RC=0 even if the image file did not exist -- fixed
#H#     changed the returncode for the function execute_script to be only either ${__TRUE} or ${__FALSE}
#H#     added the task decrypt_data_partition
#H#     changed the list of default tasks 
#H#     added the task group "all_without_os"
#H#     added more code to support encrypted phones
#H#     added the task format_data_via_twrp
#H#     added the task format_metadata_via_twrp
#H#     added the task install_twrp
#H#     added the task wipe_cache_via_twrp
#H#     added the task wipe_dalvik_via_twrp
#H#     added the task wipe_data_via_twrp
#H#     added the task mount_data_via_twrp
#H#     added the task umount_data_via_twrp
#H#     added the task task_install_archive_file
#H#     added the parameter force to the boot_phone* tasks without support for the force parameter
#H#
#H#  07.05.2023 /bs
#H#     added the task group reset_and_install_os
#H#
#H#  12.12.2023 /bs
#H#     the function init_tasks now prints a message if no config file was found
#H#     the function init_tasks now enable tracing more early if the init task parameter trace is used
#H#     egrep replaced with "grep -E"
#H#     aded the task "execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh" to the default tasks
#H#
#H#  18.12.2023 /bs
#H#     the task task_install_essential_apps now uses the "pm install" parameter to allow installation of apks created with an outdated SDK
#H#
#H#  23.12.2023 /bs
#H#     the option --bypass-low-target-sdk-block for pm install to install apks based on outdated SDKs is new in Android 14 - the
#H#       task task_install_essential_apps only uses it now if Android 14 is found; 
#H#       set the environment variable NO_BYPASS_LOW_TARGET to a non-empty value to disable this feature
#H#     the task task_install_apps now also supports the new pm install parameter --bypass-low-target-sdk-block
#H# 
#H#  19.01.2024 /bs
#H#     all tasks now print the task usage if an invalid task parameter was used
#H#     added the task task_restart_adbd_on_the_phone
#H#     added the task task_enable_adb_via_wifi
#H#     added the task task_connect_using_adb_via_wifi
#H#
#H#  20.01.2024 /bs
#H#     corrected an "error" in the task task_connect_using_adb_via_wifi : adb returns 0 even if the command fails
#H#
#H#  01.04.2024 /bs
#H#     added the task task_list_taskgroups
#H#
#H#  02.04.2024 /bs
#H#     the task task_enable_adb ignored the contents of the environment variable PUBLIC_KEY_ON_PC -- fixed
#H#     the script now exports all variables defined in the file prepare_phone.conf by default
#H# 
#H#  25.04.2024 /bs
#H#     added the task task_backup_boot_partition
#H#     added the task task_restore_boot_partition
#H#     added the task task_set_twrp_image_to_use
#H#     added the task task_select_twrp_image
#H#     added the task task_execute_command_on_the_phone
#H#     installing the OS via default tasks now creates a backup of the boot partition in the file 
#H#       /data/recovery/initial_boot${BOOT_SLOT}.img
#H#       ${BOOT_SLOT} is the slot with the new installed OS: either "_a" or "_b"
#H#     the task group all_no_magisk_no_twrp can be used to install the OS and all Apps with access via adb but without Magisk and TWRP
#H#
#H#  27.04.2024 /bs
#H#     added support for ROMs with plain root access (e.g no "su -" required to become root)
#H#     fixed some errors in the messages
#H#     rewrote some code in the function task_check_config
#H#
#H#  29.04.2024 /bs
#H#     added the task task_install_ASUS_raw_image
#H#
#H#  03.05.2024 /bs
#H#     added code to change the TWRP image to use after a script executed with execute_script failed
#H#     the task task_enable_adb now supports the parameter to select the slot 
#H#     there is now a separate task to install the Magisk Module with MicroG (that module can only be used in ROMs with the necessary prerequisites like the OmniROM)
#H#     added the task task_restart_adb_daemon
#H#     the init task parameter "nophonecheck" only worked partially -- fixed
#H#
#H#  04.05.2024 /bs
#H#     added the task task_select_twrp_image_for_install_image
#H#     added the statement
#H#       ENABLE_SINGLE_STEP_ON_ERROR=${__TRUE}
#H#     (-> prepare_phone.sh will now enable single step mode if a task fails)
#H#
#H#  05.05.2024 /bs
#H#     the task install_os now restarts the adb daemon as user root using sudo if it's running as non-root user and installing via sideload is requested
#H#     TWRP will not be installed in the boot partition any more if the OS image is installed via sideload
#H#     task task_select_twrp_image_for_install_image : added support for /e/
#H#     task task_select_twrp_image : added support for /e/ (in the function get_twrp_image_for_the_installed_OS in boot_phone_from_twrp.sh)
#H#     task task_enable_adb ended with RC=${__TRUE} even if the final reboot failed -- fixed
#H#
#H#  07.05.2024 /bs
#H#     added the task task_DebugShell
#H#
#H#  10.05.2024 /bs
#H#     added the task task_copy_file_to_phone
#H# 
#H#  18.05.2024 /bs
#H#     added the task task_reset_usb_port
#H#     added the task task_enable_single_step_mode
#H#
#H#  04.06.2024 /bs
#H#     added the task task_enable_disable_singlestep_on_error
#H#
#H#  18.06.2024 /bs
#H#     added the task task_send_notification_via_ntfy
#H#
#H#  25.06.2024 /bs
#H#     added the task task_enable_adb_in_ramdisk
#H#     the task task_boot_phone_from_twrp_image now trys to detect the TWRP image to use for the running OS on the phone
#H#  
#H#  02.08.2024 /bs
#H#     addded the apps Termux (com.termux) and NeoBackup (com.machiav3lli.backup) to the default list of applications for root access
#H#
#H#  03.08.2024 /bs
#H#     added the task task_execute_script
#H#     the function execute_script ignores the RC of the script executed if the task parameter ignorerc is used
#H#
#H#  31.08.2024 /bs
#H#     the script booted from the "wrong" TWRP image after the installation of a new OS -- fixed
#H#  
#H#  10.02.2025 /bs
#H#     the task task_restart_adb_daemon now waits until the adb daemon is usable again  
#H#
#H#  16.02.2025 /bs
#H#     fixed a minor error in the function execute_script and added some more choices to the dialog
#H#

#H#  22.02.2025 /bs
#H#     The task install_archive_file now uses the parameter -o -m for tar (-> ignore owner and time of the files in the tar archive)
#H#
#H#  16.03.2025 /bs
#H#     the script now prints the list of tasks that were completed with errors that were ignored
#H#     added code to enable or disable single step mode in the dialog used after one of the scripts failed
#H#
#H#  08.08.2025 /bs
#H#     added the option "S" or "status" to force the script to reread the phone status to the menue that is printed when a task failed
#H#     the script now rereads the phone status when the user selects "c" or "r" in the menue printed after a task failed
#H#


# global variables
#

TMP="${TMP:=/tmp}"

CHECK_STATUS_FILE="${CHECK_STATUS_FILE:=${TMP}/failed_checks.${PPID}.lst}"


# use "grep -E" instead of "egrep" if supported (this is OS independent)
#
echo test | grep -E test 2>/dev/null >/dev/null && EGREP="grep -E " || EGREP="egrep"

# name of the config file used
#
# the config file is searched in the current directory, the home directory, and in the directory /etc (in this order)
#
# Set this variable to "none" to disable the use of a config file
#
PREPARE_PHONE_CONFIG_FILE_NAME="${PREPARE_PHONE_CONFIG_FILE_NAME:=prepare_phone.conf}"

# code to disable the execution of this file
#
if [[ $0 == *.include ]] ; then
  CUR_FILENAME="${0##*/}"
  if [ "$1"x = "-h"x -o "$1"x = "--history"x ] ; then
    echo ""
    echo "### History for the file \"$0\" :"
    echo ""
    grep "^#H#" $0 | cut -c3-
    echo ""
    echo "Note:"
    echo "  Use the parameter \"--help\" to print the usage help for this file"
    echo ""
    exit 0
  elif [ "$1"x = "-H"x -o "$1"x = "--help"x ] ; then
    echo "Short usage help

Description

\"${CUR_FILENAME}\" is an include file for \"${CUR_FILENAME%.*}.sh\"

Usage: ${CUR_FILENAME%.*}.sh  [options] [task] [[...[task#]] [ -- init_task_parameter]

tasks can be a task or task group; the number of tasks is not limited. Use 

${CUR_FILENAME%.*}.sh  \"--list\" 

to list all known tasks

Known init_task_parameter are:

  nostatusfile | nostatus | no_status
    - do not write a status file with the list of failed tasks
  
  statusfile:<filename>
    - use the file <filename> for the list of failed tasks
      The default filename is \"${CHECK_STATUS_FILE}\" (= variable CHECK_STATUS_FILE)
    
  trace
    - execute the function init_tasks with \"set -x\"
    
  verbose
    - execute the function init_tasks in verbose mode

  dryrun[:dryrun_prefix]
    - execute the tasks in dry-run mode

  nodryrun
    - disable dry-run mode

  nophonecheck 
    - do not check the status of the phone

  list_defaults
    - list the default values for the variables that can be changed
    
Environment variables set can be defined before starting the script are:

$( grep "^DEFAULT"    $0 | grep -v DEFAULT_TASKS | cut -f2- -d"_" )

The values can be overwritten in the config file \"${PREPARE_PHONE_CONFIG_FILE_NAME}\"; the config file \"${PREPARE_PHONE_CONFIG_FILE_NAME}\" is searched in the current directory, 
the home directory \"${HOME}\", and in the directory /etc (in this order). Only one config file is used..

To use another config file set the environment variable PREPARE_PHONE_CONFIG_FILE_NAME before starting the script to the name of the config file to use.
Set this variable to \"none\" to disable the use of a config file.

Task parameter for files (image files, apk files, etc) must include at least one slash \"/\".

The script uses various other scripts for the tasks:

$( grep 'CUR_SCRIPT="${SCRIPT_DIR}/[a-z]' $0 | cut -f2 -d "/"  | tr -d '"' | sort | uniq )

These scripts can be downloaded from 

http://bnsmb.de/files/public/Android/

The task \"download_scripts\" can be used to download the scripts.

The documentation for these scripts is available here: 

http://bnsmb.de/My_HowTos_for_Android.html

"
    exit 1
  else
    echo "ERROR: $0 is an include file for ${CUR_FILENAME%.*}.sh "
    echo "       use  \"sh $0 -H\" or \"sh $0 --help\" to print a short usage"
    echo "       use  \"sh $0 -h\" or \"sh $0 --history\" to print the history of this file"
    exit 5
  fi
fi

# create a function called "whence" if the builtin "whence" is not defined
#
type -f whence 2>/dev/null 1>/dev/null || function whence { which $* ; }

# create a function dummy called "timeout" if the executable timeout is not found
#
type -f timeout 2>/dev/null 1>/dev/null || function timeout { shift ; $* ; }

# define the include file version (optional)
#
INCLUDE_FILE_VERSION="1.0.0.0"

#
# the value of CUR_INCLUDE_FILE changes if there are additional include files to read
#
THIS_INCLUDE_FILE="${CUR_INCLUDE_FILE}"

THIS_INCLUDE_FILE_NAME="${CUR_INCLUDE_FILE##*/}"
THIS_INCLUDE_FILE_DIR="${CUR_INCLUDE_FILE%/*}"


# URLs with the primary source for this file
#
INCLUDE_FILE_DOWNLOAD_URL="http://bnsmb.de/files/public/Android/prepare_phone.include"

# URL to download the scripts used by this include file
#
SCRIPTS_DOWNLOAD_URL="http://bnsmb.de/files/public/Android"


# disable the parameter "all"
# (optional; default: the parameter "all" is enabled)
#
# DISABLE_THE_PARAMETER_ALL=${__TRUE}


TASK_GROUP_testtasks="
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc

# install_magisk_modules:\${MICROG_MAGISK_MODULE}:ignorerc
"


# ---------------------------------------------------------------------
# define the tasks to be executed for the parameter "all"
# (optional, default: execute all defined tasks if "all" is used)
#
# The tasks in this list are necessary to install the OS and all related apps and addons from scratch
#
# Format of the entries in this list
#
#  task_name[:taskparameter1[...:taskparameter#]]
#
#T# TASK_GROUP_all - install the OS into the inactive slot, Customize the OS and install Applications, Scripts, Magisk, Magisk Modules, TWRP

DEFAULT_TASKS="
enable_disable_abort_on_error:enable

# select the correct TWRP image for the currently running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image:force

install_os:noreboot:factory_reset

# the adb daemon sometimes hangs after installing the new image 
#
restart_adb_daemon

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:next

# install TWRP into the boot partition
#
install_twrp:noreboot:next

#
# first install Magisk v25.x into the boot partition; this installation is necessary to
# enable the access via adb to the phone; the Magisk installation will be overwritten later
# with Magisk v26 or newer
#
install_magisk_in_boot_partition_only:noreboot:next

# enable adb access using Magisk
#
enable_adb:reboot

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# wait until the new OS is up and running with working adb access
#
wait_for_access_via_adb:240

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc
#

# install Magisk in the boot partition
#
install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk

wait_for_access_via_adb:120

# enable adb
#
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120

# task_enable_single_step_mode


#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot
wait_for_access_via_adb:120
install_the_magisk_app

# customize the OS: install Scripts, Apps, and Magisk Modules

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable
install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh
# execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot
install_essential_apps:ignorerc
install_essential_magisk_modules:ignorerc

#
# The variable MICROG_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module with MicroG
#
install_magisk_modules:\${MICROG_MAGISK_MODULE}:ignorerc
#
#
# The variable DISABLE_FAKE_STORE_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module to Disable the FakeStore
#
install_magisk_modules:\${DISABLE_FAKE_STORE_MAGISK_MODULE}:ignorerc
#
#
# The variable NEO_BACKUP_TAR_FILE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to copy the tar file to the phone
#
install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh

# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

#
enable_root_access_for_apps:reboot
execute_script_on_the_phone:ignorerc
wait_for_access_via_adb
"


# remove the comments from the list of default tasks
#
DEFAULT_TASKS="$( echo "${DEFAULT_TASKS}" | grep -v "^#" )"


# define the tasks that should never be executed for the parameter "all"
# (optional, if a task is defined in DEFAULT_TASKS and NO_DEFEAULT_TASKS
#  it is not executed if the parameter "all" is used)
#
NO_DEFAULT_TASKS="
"

# Define Task groups -- Task groups can be used like tasks
# e.g.
#
# ./execute_osbuild_check_tasks.sh install_magisk
#
# executes all tasks in the task group install_magisk
#
# The name of a task group MUST start with TASK_GROUP_
#
# define the tasks to be executed for the parameter "all"
# (optional, default: execute all defined tasks if "all" is used)
#

# ---------------------------------------------------------------------
#T# TASK_GROUP_all_test  - task group for testing only
#
TASK_GROUP_all_test="# 
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# install the OS image via sideload 
# (if using auto here the following tasks will fail because the necessary boot from the TWRP image after the installation changes the current boot slot)
#
install_os:noreboot:auto:factory_reset:restart_as_root

# select the TWRP image necessary for the just installed OS (define the environment variable NEW_TWRP_IMAGE to disable this task)
#
select_twrp_image_for_install_image

#
# after install an OS image using the sideload feature the /data partition is not mounted -> reboot from the TWRP image to get a mounted /data partition for the next tasks
#
boot_phone_from_twrp_image:force

# IMPORTANT: now all tasks must be done in the active boot slot!

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:active

# install TWRP in the boot partition
#
# install_twrp:noreboot:active

#
# first install Magisk v25.x into the boot partition
#
install_magisk_in_boot_partition_only:noreboot:active

# copy inital apks to the phone
#
copy_file_to_phone:/data/backup/Android/EssentialApps/com.termoneplus_501.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.jecelyin.editor.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.offsec.nhterm_2020040001.apk:/data/recovery:ignorerc


# create a Magisk init rc script to enable the access via adb
#
enable_adb:reboot:active

# for debugging only
#
# DebugShell

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc


install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120

enable_root_access_for_the_shell:reboot

wait_for_access_via_adb:120
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot

wait_for_access_via_adb:120

install_the_magisk_app
wait_for_access_via_adb:120

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable
install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot

# use a separate directory for the apps to install for non-OmniROM ROMs 
#
install_essential_apps:/data/backup/Android/Test_EssentialApps:ignorerc
install_essential_magisk_modules:/data/backup/Android/Test_EssentialMagiskModules

# install_essential_apps:/data/backup/Android/Essential_Apps_for_ASUS_Android
# install_essential_magisk_modules:ignorerc

install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

enable_root_access_for_apps:reboot

execute_script_on_the_phone:ignorerc
"



# ---------------------------------------------------------------------
#T# TASK_GROUP_All - install the OS either via install or via sideload into the inactive slot, customize the OS, and install Applications, Scripts, Magisk, Magisk Modules, and TWRP

#
TASK_GROUP_All="# 
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# install the OS image via sideload 
# (if using auto here the following tasks will fail because the necessary boot from the TWRP image after the installation changes the current boot slot)
#
install_os:noreboot:auto:factory_reset:restart_as_root

# select the TWRP image necessary for the just installed OS (define the environment variable NEW_TWRP_IMAGE to disable this task)
#
select_twrp_image_for_install_image

#
# after install an OS image using the sideload feature the /data partition is not mounted -> reboot from the TWRP image to get a mounted /data partition for the next tasks
#
boot_phone_from_twrp_image:force

# IMPORTANT: now all tasks must be done in the active boot slot!

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:active

# install TWRP in the boot partition
#
# install_twrp:noreboot:active

#
# first install Magisk v25.x into the boot partition
#
install_magisk_in_boot_partition_only:noreboot:active

# copy inital apks to the phone
#
copy_file_to_phone:/data/backup/Android/EssentialApps/com.termoneplus_501.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.jecelyin.editor.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.offsec.nhterm_2020040001.apk:/data/recovery:ignorerc


# create a Magisk init rc script to enable the access via adb
#
enable_adb:reboot:active

# for debugging only
#
# DebugShell

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc

install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120

enable_root_access_for_the_shell:reboot

wait_for_access_via_adb:120
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot

wait_for_access_via_adb:120

install_the_magisk_app
wait_for_access_via_adb:120

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable
install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

# execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot


# use a separate directory for the apps to install for non-OmniROM ROMs 
#
install_essential_apps:/data/backup/Android/Test_EssentialApps:ignorerc
install_essential_magisk_modules:/data/backup/Android/Test_EssentialMagiskModules:ignorerc


# install_essential_apps:/data/backup/Android/Essential_Apps_for_ASUS_Android
# install_essential_magisk_modules:ignorerc


# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh

# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

enable_root_access_for_apps:reboot

execute_script_on_the_phone:ignorerc
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_all_sideload - install the OS via sideload into the inactive slot, customize the OS, and install Applications, Scripts, Magisk, Magisk Modules, and TWRP
#
# History
#   04.05.2024 
#    removed the task install_twrp
#
TASK_GROUP_all_sideload="# 
  
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# install the OS image via sideload 
# (if using auto here the following tasks will fail because the necessary boot from the TWRP image after the installation changes the current boot slot)
#
install_os:noreboot:sideload:factory_reset:restart_as_root

# select the TWRP image necessary for the just installed OS (define the environment variable NEW_TWRP_IMAGE to disable this task)
#
select_twrp_image_for_install_image

#
# after install an OS image using the sideload feature the /data partition is not mounted -> reboot from the TWRP image to get a mounted /data partition for the next tasks
#
boot_phone_from_twrp_image:force

# IMPORTANT: now all tasks must be done in the active boot slot!

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:active

# install TWRP in the boot partition
#
# install_twrp:noreboot:active

#
# first install Magisk v25.x into the boot partition
#
install_magisk_in_boot_partition_only:noreboot:active

# copy inital apks to the phone
#
copy_file_to_phone:/data/backup/Android/EssentialApps/com.termoneplus_501.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.jecelyin.editor.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.offsec.nhterm_2020040001.apk:/data/recovery:ignorerc


# create a Magisk init rc script to enable the access via adb
#
enable_adb:reboot:active


# for debugging only
#
# DebugShell

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc

install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120

enable_root_access_for_the_shell:reboot

wait_for_access_via_adb:120
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot

wait_for_access_via_adb:120

install_the_magisk_app
wait_for_access_via_adb:120

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable

enable_adb_in_ramdisk:ignorerc

install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

# execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot

# use a separate directory for the apps to install for non-OmniROM ROMs 
#
install_essential_apps:/data/backup/Android/Test_EssentialApps:ignorerc
install_essential_magisk_modules:/data/backup/Android/Test_EssentialMagiskModules:ignorerc

# install_essential_apps:/data/backup/Android/Essential_Apps_for_ASUS_Android
# install_essential_magisk_modules:ignorerc

# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh


# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

enable_root_access_for_apps:reboot

execute_script_on_the_phone:ignorerc
"



# ---------------------------------------------------------------------
#T# TASK_GROUP_os_twrp_magisk_sideload - install the OS via sideload into the inactive slot, install TWRP and Magisk and enable adb
#
# History
#   16.05.2024 
#    task group rewritten

TASK_GROUP_os_twrp_magisk_backup_sideload="# 
  
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# install the OS image via sideload 
# (if using auto here the following tasks will fail because the necessary boot from the TWRP image after the installation changes the current boot slot)
#
install_os:noreboot:sideload:factory_reset:restart_as_root

# select the TWRP image necessary for the just installed OS (define the environment variable NEW_TWRP_IMAGE to disable this task)
#
select_twrp_image_for_install_image

#
# after install an OS image using the sideload feature the /data partition is not mounted -> reboot from the TWRP image to get a mounted /data partition for the next tasks
#
boot_phone_from_twrp_image:force

# IMPORTANT: now all tasks must be done in the active boot slot!

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:active

# install TWRP in the boot partition
#
# install_twrp:noreboot:active

#
# first install Magisk v25.x into the boot partition
#
install_magisk_in_boot_partition_only:noreboot:active


# create a Magisk init rc script to enable the access via adb
#
enable_adb:reboot:active

# for debugging only
#
# DebugShell

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc

install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120

enable_root_access_for_the_shell:reboot

wait_for_access_via_adb:120
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot

wait_for_access_via_adb:120

install_the_magisk_app
wait_for_access_via_adb:120

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable

enable_adb_in_ramdisk:ignorerc

install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot

# use a separate directory for the apps to install for non-OmniROM ROMs 
#
# install_essential_apps:/data/backup/Android/Test_EssentialApps:ignorerc
# install_essential_magisk_modules:/data/backup/Android/Test_EssentialMagiskModules:ignorerc

# install_essential_apps:/data/backup/Android/Essential_Apps_for_ASUS_Android
# install_essential_magisk_modules:ignorerc

# install Neobackup App
#
install_apps:/data/backup/Android/apps/com.machiav3lli.backup_8318.apk

# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh

# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

enable_root_access_for_apps:reboot

execute_script_on_the_phone:ignorerc
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_asus_android - install the ASUS Android via sideload into the inactive slot, customize the OS, and install Applications, Scripts, Magisk, Magisk Modules, and TWRP
#
#
TASK_GROUP_asus_android="# 
  
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# install the OS image via sideload 
# (if using auto here the following tasks will fail because the necessary boot from the TWRP image after the installation changes the current boot slot)
#
install_os:noreboot:sideload:factory_reset:restart_as_root:/data/backup/ASUS_ZENFONE8/ASUS_firmware/Android_13/CURRRENT.zip

# select the TWRP image necessary for the just installed OS (define the environment variable NEW_TWRP_IMAGE to disable this task)
#
select_twrp_image_for_install_image

#
# after install an OS image using the sideload feature the /data partition is not mounted -> reboot from the TWRP image to get a mounted /data partition for the next tasks
#
boot_phone_from_twrp_image:force

# IMPORTANT: now all tasks must be done in the active boot slot!

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:active

# install TWRP in the boot partition
#
# install_twrp:noreboot:active

#
# first install Magisk v25.x into the boot partition
#
install_magisk_in_boot_partition_only:noreboot:active

# copy inital apks to the phone
#
copy_file_to_phone:/data/backup/Android/EssentialApps/com.termoneplus_501.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.jecelyin.editor.apk:/data/recovery:ignorerc
copy_file_to_phone:/data/backup/Android/EssentialApps/com.offsec.nhterm_2020040001.apk:/data/recovery:ignorerc


# create a Magisk init rc script to enable the access via adb
#
enable_adb:reboot:active

# for debugging only
#
# DebugShell

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc

install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120

enable_root_access_for_the_shell:reboot

wait_for_access_via_adb:120
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot

wait_for_access_via_adb:120

install_the_magisk_app
wait_for_access_via_adb:120

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable

enable_adb_in_ramdisk:ignorerc

install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot

# use a separate directory for the apps to install for non-OmniROM ROMs 
#
install_essential_apps:ignorerc
install_essential_magisk_modules:ignorerc

# install_essential_apps:/data/backup/Android/Essential_Apps_for_ASUS_Android
# install_essential_magisk_modules:ignorerc

enable_root_access_for_apps:reboot

execute_script_on_the_phone:ignorerc
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_all_no_magisk_no_twrp - install the OS into the inactive slot, enable adb, install Applications; do not install TWRP and deinstall Magisk after the customizing is done
#
TASK_GROUP_all_no_magisk_no_twrp="# 
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image

# Note: Task parameter 'auto' -> select the installation method ('twrp install' or 'twrp sideload') depending on the file name of the OS image to install
#       use 'sideload' instead of auto to force installing via 'twrp sideload'
#
install_os:noreboot:factory_reset:auto

# the adb daemon sometimes hangs after installing the new image 
#
kill_adb_daemon

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:next


#
# first install Magisk v25.x into the boot partition; this installation is necessary to
# enable the access via adb to the phone; the Magisk installation will be overwritten later
# with Magisk v26 or newer
#
install_magisk_in_boot_partition_only:noreboot:next

enable_adb:reboot

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# wait until the new OS is up and running with working adb access
#
wait_for_access_via_adb:240:kill

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#

# install Magisk in the boot partition
#
install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk

wait_for_access_via_adb:120:kill

# enable adb
#
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120:kill

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable


execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh

# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh

# Access via adb is working now and we do not need root access anymore -- we do not need Magisk anymore
#
restore_boot_partition:twrp:noreboot

install_essential_apps

execute_script_on_the_phone:ignorerc
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_reset_and_install_os  - install the OS into the inactive slot via install or sideload (auto) and do a factory reset
#
TASK_GROUP_reset_and_install_os_auto="
# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

boot_phone_from_twrp_image

install_os:reboot:factory_reset:auto
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_reset_and_install_os  - install the OS into the inactive slot via install or sideload (auto) and do a factory reset
#
TASK_GROUP_reset_and_install_os_sideload="
# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

boot_phone_from_twrp_image

install_os:noreboot:sideload:factory_reset:reboot

# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh

"

# ---------------------------------------------------------------------
#T# TASK_GROUP_reset_and_install_os  - install the OS into the inactive slot via install or sideload (auto) and do a factory reset
#
TASK_GROUP_reset_and_install_os_via_install="
# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

boot_phone_from_twrp_image

install_os:noreboot:factory_reset:reboot

# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh

"


# ---------------------------------------------------------------------
#T# TASK_GROUP_all_without_os - all default tasks w/o installing the OS into the inactive slot
#
TASK_GROUP_all_without_os="
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc
#
# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

boot_phone_from_twrp_image
install_twrp:noreboot:next
#
# first install Magisk v25.x into the boot partition; this installation is necessary to
# enable the access via adb to the phone; the Magisk installation will be overwritten later
# with Magisk v26 or newer
#
install_magisk_in_boot_partition_only:noreboot:next
enable_adb:reboot
#
install_magisk_in_data_adb_only:noreboot:copy_apk
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120:kill
#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot
wait_for_access_via_adb:120:kill
install_the_magisk_app
wait_for_access_via_adb:120:kill
decrypt_data_partition
enable_disable_abort_on_error:disable
install_archive_file:twrp:reboot
install_essential_scripts
install_essential_apps
install_essential_magisk_modules
enable_root_access_for_apps:reboot
decrypt_data_partition
execute_script_on_the_phone:ignorerc
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_os_twrp_magisk - install the OS into the inactive slot, and install TWRP and Magisk 
#
# History
#
#  16.03.2025 /bs
#    task group rewritten
#
TASK_GROUP_os_twrp_magisk="
enable_disable_abort_on_error:enable

# select the correct TWRP image for the currently running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image:force

install_os:noreboot:factory_reset

# the adb daemon sometimes hangs after installing the new image 
#
restart_adb_daemon

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:next

# install TWRP into the boot partition
#
install_twrp:noreboot:next

#
# first install Magisk v25.x into the boot partition; this installation is necessary to
# enable the access via adb to the phone; the Magisk installation will be overwritten later
# with Magisk v26 or newer
#
install_magisk_in_boot_partition_only:noreboot:next

# enable adb access using Magisk
#
enable_adb:reboot

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# wait until the new OS is up and running with working adb access
#
wait_for_access_via_adb:240

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc
#

# install Magisk in the boot partition
#
install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk

wait_for_access_via_adb:120

# enable adb
#
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120

# task_enable_single_step_mode


#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot
wait_for_access_via_adb:120
install_the_magisk_app

# customize the OS: install Scripts, Apps, and Magisk Modules

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable
install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh
# execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot
#install_essential_apps:ignorerc
#install_essential_magisk_modules:ignorerc

#
# The variable MICROG_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module with MicroG
#
#install_magisk_modules:\${MICROG_MAGISK_MODULE}:ignorerc
#
#
# The variable DISABLE_FAKE_STORE_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module to Disable the FakeStore
#
#install_magisk_modules:\${DISABLE_FAKE_STORE_MAGISK_MODULE}:ignorerc
#

# The variable NEO_BACKUP_TAR_FILE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to copy the tar file to the phone
#
install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh

#
enable_root_access_for_apps:reboot
execute_script_on_the_phone:ignorerc
wait_for_access_via_adb
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_os_twrp_magisk_backup - install the OS into the inactive slot, and install TWRP and Magisk 
#
# History
#
#  16.03.2025 /bs
#    task group rewritten
#
TASK_GROUP_os_twrp_magisk_bkp="
enable_disable_abort_on_error:enable

# select the correct TWRP image for the currently running OS on the phone
#
select_twrp_image:ignorerc
#

# install the OS
#
boot_phone_from_twrp_image:force

install_os:noreboot:factory_reset

# the adb daemon sometimes hangs after installing the new image 
#
restart_adb_daemon

# create a backup of the initial boot partition in /data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img
#
backup_boot_partition:next

# install TWRP into the boot partition
#
install_twrp:noreboot:next

#
# first install Magisk v25.x into the boot partition; this installation is necessary to
# enable the access via adb to the phone; the Magisk installation will be overwritten later
# with Magisk v26 or newer
#
install_magisk_in_boot_partition_only:noreboot:next

# enable adb access using Magisk
#
enable_adb:reboot

# do first configurations via Android cli commands if necessary
#
execute_script_on_the_phone:ignorerc:pre_install.sh

# wait until the new OS is up and running with working adb access
#
wait_for_access_via_adb:240

# select the correct TWRP image for the now running OS on the phone
#
task_select_twrp_image:ignorerc
#

# install Magisk in the boot partition
#
install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk

wait_for_access_via_adb:120

# enable adb
#
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120

# task_enable_single_step_mode


#
# the next step is necessary to install Magisk v26 or newer
#
install_magisk_v26_in_boot_partition:active:reboot
wait_for_access_via_adb:120
install_the_magisk_app

# customize the OS: install Scripts, Apps, and Magisk Modules

install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh
enable_disable_abort_on_error:disable
install_essential_scripts
execute_script_on_the_phone:ignorerc:/data/develop/android/scripts_on_linux/enable_wlan.sh
# execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot
#install_essential_apps:ignorerc
#install_essential_magisk_modules:ignorerc

#
# The variable MICROG_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module with MicroG
#
#install_magisk_modules:\${MICROG_MAGISK_MODULE}:ignorerc
#
#
# The variable DISABLE_FAKE_STORE_MAGISK_MODULE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to install the Magisk Module to Disable the FakeStore
#
#install_magisk_modules:\${DISABLE_FAKE_STORE_MAGISK_MODULE}:ignorerc
#

# The variable NEO_BACKUP_TAR_FILE must be defined before starting the script either in the environment
# or in the file prepare_phone.conf to copy the tar file to the phone
#
install_archive_file:twrp:reboot:script=/cache/correct_setlinux_for_wifconifg.sh

# install Neobackup App
#
install_apps:/data/backup/Android/apps/com.machiav3lli.backup_8318.apk

# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh

#
enable_root_access_for_apps:reboot
execute_script_on_the_phone:ignorerc
wait_for_access_via_adb
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_install_neobackup  - install the NeoBackup App and the NeoBackup backup data files
#
# History
#
#  16.03.2025 /bs
#    task group created
#
TASK_GROUP_install_neobackup="
# install Neobackup App
#
install_apps:/data/backup/Android/apps/com.machiav3lli.backup_8318.apk

# install the NeoBackup data files
#
install_archive_file:\${NEO_BACKUP_TAR_FILE}:ignorerc:script=/sdcard/Download/change_owner_for_neobackup_dir.sh
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_install_termux - install Termux and the tar archive with the termux filesystem
#
TASK_GROUP_install_termux="
execute_script:/data/develop/android/scripts_on_linux/install_termux.sh:ignorerc:noreboot
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_update_os_w_Magisk25  - update the OS; install TWRP and Magisk v25 into the boot partition for the new OS
#
TASK_GROUP_update_os_w_Magisk25="

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

enable_disable_abort_on_error:enable
boot_phone_from_twrp_image
install_os:noreboot
install_twrp:noreboot:next
install_magisk_in_boot_partition_only:reboot:next
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_update_os - install TWRP and Magisk v26 (or newer) into the boot partition for the new OS
#
TASK_GROUP_update_os="
enable_disable_abort_on_error:enable

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

boot_phone_from_twrp_image
install_os:noreboot
install_twrp:noreboot:next
install_magisk_in_boot_partition_only:reboot:next
wait_for_access_via_adb:120:kill
install_magisk_v26_in_boot_partition:active:reboot
# seems that the root access in Magisk get's lost ...
enable_root_access_for_apps:default:2000:reboot:ignorerc
# 
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_install_magisk - Install Magisk
#
TASK_GROUP_install_magisk="

# select the correct TWRP image for the running OS on the phone
#
select_twrp_image:ignorerc

install_the_magisk_app
install_magisk_in_boot_partition:current
wait_for_access_via_adb:60:kill
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:60:kill
install_essential_magisk_modules:reboot
# "


# ---------------------------------------------------------------------
#T# TASK_GROUP_raw_image_with_magisk - install the raw Android image from ASUS, install Magisk, enable adb  // Test Entry!
#
TASK_GROUP_raw_image_with_magisk="# 
install_ASUS_raw_image
#
# /data is not mounted after installing the raw image
# -> use TWRP to format /data
#
# ??? boot_phone_from_twrp_image:ignorerc
# ??? format_data_via_twrp
#

# reboot the phone from the TWRP image to ensure that the now formated /data partition is mounted
#
boot_phone_from_twrp_image:force

install_magisk_in_boot_partition_only:noreboot:_a
boot_phone_from_twrp_image:force
enable_adb:reboot:_a
install_magisk_in_data_adb_only:noreboot:copy_apk:use_apk
wait_for_access_via_adb:120:kill
enable_root_access_for_the_shell:reboot
wait_for_access_via_adb:120:kill
install_the_magisk_app
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_configure_orangefox - copy the OrangeFox config files to the phone
#
TASK_GROUP_configure_orangefox="
# install the config Data files for the OrangeFox recovery
#
install_archive_file:/data/backup/Android/OrangeFox_data_files.tar:noreboot:script=/sdcard/Fox/orange_fox_config.sh
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_abort_on_error - abort the task execution after a task ends with an error
#
TASK_GROUP_abort_on_error="
enable_disable_abort_on_error:enable
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_no_abort_on_error - do not abort the task execution after a task ends with an error
#
TASK_GROUP_no_abort_on_error="
enable_disable_abort_on_error:disable
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_bootloader - wait until the phone is booted into the bootloader
#
TASK_GROUP_wait_for_bootloader="
wait_for_phone_state:4
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_fastboot - wait until the phone is booted into the fastbootd
#
TASK_GROUP_wait_for_fastboot="
wait_for_phone_state:5
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_androidos - wait until the phone is booted into the Android OS
#
TASK_GROUP_wait_for_androidos="
wait_for_phone_state:3
"

# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_safemode - wait until the phone is booted into the Android OS in safe mode
#
TASK_GROUP_wait_for_safemode="
wait_for_phone_state:6
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_twrp_image - wait until the phone is booted from the TWRP image
#
TASK_GROUP_wait_for_twrp_image="
wait_for_phone_state:1
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_twrp_recovery - wait until the phone is booted from the TWRP recovery
#
TASK_GROUP_wait_for_twrp_recovery="
wait_for_phone_state:2
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_lineageos_recovery - wait until the phone is booted into the recovery from the LineageOS
#
TASK_GROUP_wait_for_lineageos_recovery="
wait_for_phone_state:7
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_wait_for_sideload - wait until the phone is booted into the sideload mode
#
TASK_GROUP_wait_for_sideload="
wait_for_phone_state:8
"


# ---------------------------------------------------------------------
#T# TASK_GROUP_refresh - download the current version of the file prepare_phone.include
#
TASK_GROUP_refresh="
update_include_file"


# ---------------------------------------------------------------------
#T# TASK_GROUP_refresh_all - download the current version of all used scripts and the file prepare_phone.include
#
TASK_GROUP_refresh_all="
download_scripts:default
update_include_file
"


# ---------------------------------------------------------------------



# list of command hints to fix some of the found issues
# The contents of this variable are printed out at script end
# Each task function can add some hints to this global variable
#
COMMAND_HINTS=""

# global list of all error messages
# These error messages are printed again at script end.
# Use LogErrorMsg to log an error message and add the message to this list
#
ERROR_MESSAGES=""


# global list of all warning messages
# These warning messages are printed again at script end.
# Use LogWarningMsg to log an warning message and add the message to this list
#
WARNING_MESSAGES=""


# if read by the wrapper script the variable with the filename of this
# script is "${CUR_INCLUDE_FILE}"
#

# global variables for all checks
#

#
# for dry-run mode
#
DEFAULT_DRYRUN_PREFIX="echo"

DRYRUN_PREFIX="${DRYRUN_PREFIX:=${DEFAULT_DRYRUN_PREFIX}}"

# default directory with the scripts to install and configure the phone
#
DEFAULT_SCRIPT_DIR="/data/develop/android/scripts_on_linux"

# directory with the scripts to install and configure the phone
#
SCRIPT_DIR="${SCRIPT_DIR:=${DEFAULT_SCRIPT_DIR}}"


#
# directory for files uploaded via adb push on the phone
#
DEFAULT_DOWNLOAD_DIR_ON_THE_PHONE="/sdcard/Download"

DOWNLOAD_DIR_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE:=${DEFAULT_DOWNLOAD_DIR_ON_THE_PHONE}}"


# include file with the function to boot the phone
#
PHONE_FUNCTIONS_INCLUDE_FILE="${SCRIPT_DIR}/boot_phone_from_twrp.sh"


# default OS image to install
#
DEFAULT_OS_IMAGE_TO_INSTALL="/data/backup/ASUS_ZENFONE8/current_os_image.img"

# OS image file to use (can be overwritten by a parameter for the script)
#
OS_IMAGE_TO_INSTALL="${OS_IMAGE_TO_INSTALL:=${DEFAULT_OS_IMAGE_TO_INSTALL}}"


# default TWRP image
#
DEFAULT_TWRP_IMAGE="${DEFAULT_TWRP_IMAGE:=/data/backup/ASUS_ZENFONE8/twrp/current_twrp.img}"

# TWRP image to use
#
TWRP_IMAGE="${TWRP_IMAGE:=${DEFAULT_TWRP_IMAGE}}"


# default Magisk App apk file (must be Magisk v25 or older because the installation method changed for Magisk v26)
#
DEFAULT_MAGISK_APK_FILE="/data/backup/Android/EssentialApps_Backup/Magisk-v25.2.apk"


# default directory with the essential apps
#
DEFAULT_ESSENTIAL_APPS_DIR="/data/backup/Android/EssentialApps"

# directory with the essential apps
#
ESSENTIAL_APPS_DIR="${ESSENTIAL_APPS_DIR:=${DEFAULT_ESSENTIAL_APPS_DIR}}"


# default directory with the essential scripts
#
DEFAULT_ESSENTIAL_SCRIPTS_DIR="/data/backup/Android/EssentialScripts/"

# directory with the essential scripts
#
ESSENTIAL_SCRIPTS_DIR="${ESSENTIAL_SCRIPTS_DIR:=${DEFAULT_ESSENTIAL_SCRIPTS_DIR}}"


# default directory with the essential Magisk Modules
#
DEFAULT_ESSENTIAL_MAGISK_MODULES_DIR="/data/backup/Android/EssentialMagiskModules"

# directory with the essential Magisk Modules
#
ESSENTIAL_MAGISK_MODULES_DIR="${ESSENTIAL_MAGISK_MODULES_DIR:=${DEFAULT_ESSENTIAL_MAGISK_MODULES_DIR}}"


# default directory for scripts on the phone
#
DEFAULT_SCRIPT_DIR_ON_THE_PHONE="/data/scripts"


# directory for scripts on the phone
#
SCRIPT_DIR_ON_THE_PHONE="${SCRIPT_DIR_ON_THE_PHONE:=${DEFAULT_SCRIPT_DIR_ON_THE_PHONE}}"

# directory used for uploading scripts to the phone
#
DEFAULT_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/scripts"
  
UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE="${UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE:=${DEFAULT_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}}"
  

# directory used for uploading Magisk Modules to the phone
#
DEFAULT_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/MagiskModules"

UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE="${UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE:=${DEFAULT_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}}"


# global variable for the UID of the Android shell
#
# The variable is set in the task
#   task_enable_adb
# and used in the task 
#  task_enable_root_access_for_the_shell
#
# Using the variable is optional; if the variable is not set there are two more reboots of the phone.
#
SHELL_UID=""


# default list of apps for which root access should be enabled in Magisk
#
DEFAULT_APPS_FOR_ROOT_ACCESS="com.machiav3lli.backup,com.termux,com.mixplorer,com.keramidas.TitaniumBackup,io.github.muntashirakon.AppManager,com.matoski.adbm,com.fox2code.mmm"

APPS_FOR_ROOT_ACCESS="${APPS_FOR_ROOT_ACCESS:=${DEFAULT_APPS_FOR_ROOT_ACCESS}}"


# default Titanium license file

DEFAULT_TITANIUM_LICENSE_FILE="/data/backup/Android/Licenses/TitaniumBackup_license.txt"

TITANIUM_LICENSE_FILE="${TITANIUM_LICENSE_FILE:=${DEFAULT_TITANIUM_LICENSE_FILE}}"


# default Titanium update.zip file to restore the backups
#
DEFAULT_TITANIUM_UPDATE_ZIP_FILE="/data/backup/ASUS_ZENFONE8/current_update.zip"

TITANIUM_UPDATE_ZIP_FILE="${TITANIUM_UPDATE_ZIP_FILE:=${DEFAULT_TITANIUM_UPDATE_ZIP_FILE}}"


# default Titanium files and directories on the phone
#
DEFAULT_TITANIUM_LICENSE_FILE_ON_THE_PHONE="/sdcard/TitaniumBackup_license.txt"

TITANIUM_LICENSE_FILE_ON_THE_PHONE="${TITANIUM_LICENSE_FILE_ON_THE_PHONE:=${DEFAULT_TITANIUM_LICENSE_FILE_ON_THE_PHONE}}"

# default directory with the backups created by Titanium
#
DEFAULT_TITANIUM_BACKUP_DIR_ON_THE_PHONE="/sdcard/TitaniumBackup"

TITANIUM_BACKUP_DIR_ON_THE_PHONE="${TITANIUM_BACKUP_DIR_ON_THE_PHONE:=${DEFAULT_TITANIUM_BACKUP_DIR_ON_THE_PHONE}}"


# default upload directory or file for the zip file with the Titanium backpus
#
DEFAULT_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/"

TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE="${TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE:=${DEFAULT_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}}"


# default Titanium app
#
DEFAULT_TITANIUM_APP="com.keramidas.TitaniumBackup"

TITANIUM_APP="${TITANIUM_APP:=${DEFAULT_TITANIUM_APP}}"

# default post install script
#
DEFAULT_POST_INSTALL_SCRIPT="post_install.sh"

POST_INSTALL_SCRIPT="${POST_INSTALL_SCRIPT:=${DEFAULT_POST_INSTALL_SCRIPT}}"


# wget binary
#
WGET="$( which wget )"

# default options for WGET
#
WGET_OPTIONS=""

# curl binary
#
CURL="$( which curl )"

# default options for CURL
#
CURL_OPTIONS=""

# for documentation only (-> these statements are only necessary for the grep command used to set the variable LIST_OF_USED_SCRIPTS)
#
CUR_SCRIPT="${SCRIPT_DIR}/enable_root_access_via_magisk.sh"
CUR_SCRIPT="${SCRIPT_DIR}/enable_adb_using_magisk.sh"
CUR_SCRIPT="${SCRIPT_DIR}/install_twrp_from_within_twrp.sh"
CUR_SCRIPT="${SCRIPT_DIR}/boot_phone_from_twrp.sh"
CUR_SCRIPT="${SCRIPT_DIR}/usbreset"
CUR_SCRIPT="${SCRIPT_DIR}/enable_adb_in_recovery_ramdisk"

LIST_OF_USED_SCRIPTS="$( grep 'CUR_SCRIPT="${SCRIPT_DIR}/[a-z]' ${CUR_INCLUDE_FILE} | cut -f2 -d "/"  | tr -d '"' | sort | uniq )"


# global variables used by the tasks; this variable is used in the task task_check_config
#
# format of the entries in this list
#
#   variablename[:type][:location]
#
# "type" is optional; known types are:
#
#  dir    - the value of the variable is a directory
#  file   - the value of the variable is a file
#  script - the value of the variable is an executable (script, binary, etc)
#  number - the value of the variable must be a number
#
# There is no default for "type"
#
# "location" is the location for files and directories:
#
#  pc    - the file/dir must exist on the PC
#  phone - the file/dir is on the phone
#
# Default for "location" is "pc"
#
CONFIG_VARIABLES="
PHONE_FUNCTIONS_INCLUDE_FILE:script:pc
SCRIPT_DIR:dir:pc
OS_IMAGE_TO_INSTALL:file
TWRP_IMAGE:file
DEFAULT_TWRP_IMAGE:file
MAGISK_APK_FILE:file
MAGISK_v25_APK_FILE:file
MAGISK_v26_APK_FILE:file
ESSENTIAL_APPS_DIR:dir
ESSENTIAL_SCRIPTS_DIR:dir
ESSENTIAL_MAGISK_MODULES_DIR:dir
SCRIPT_DIR_ON_THE_PHONE:dir:phone
UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE:dir:phone
UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE:dir:phone
ARCHIVE_FILE:file
PUBLIC_KEY_ON_PC:file
"


# template for new tasks:
#

# ----------------------------------------------------------------------
# task_template - this a template for the function for a new check task
#
# function: [add the task description here]
#
# usage: [add the usage help for the task here] [slot] [reboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_template {
  typeset __FUNCTION="task_template"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [parameter_for_the_script] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the \"${PARAMETER_KEY}\" to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
           CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
           
#          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
#          PRINT_TASK_USAGE=${__TRUE}
#          THISRC=${__FALSE}
#          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Installing the Android OS image \"${OS_IMAGE_TO_INSTALL}\" using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))



      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# create a local backup of the current boot partition contents before installing Magisk
#
# Usage: create_boot_partition_backup_like_magisk [slot]
#
# slot must be either "_a" or "-b" ; the parameter is mandatory
#
# Do NOT use this function before the 1st reboot of the new installed OS!
#
#
# returns: ${__TRUE} - slot to use written to STDOUT
#          ${__FALSE} - empty string written to STDOUT
#
#
function create_boot_partition_backup_like_magisk {
  typeset __FUNCTION="create_boot_partition_backup_like_magisk"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__FALSE}

  typeset CUR_SLOT="$1"
  
  typeset CUR_BOOT_PARTITION=""

  typeset CUR_BACKUP_DIR=""
  typeset CUR_BOOT_IMG_FILE=""
    
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""
  
  if [ "${CUR_SLOT}"x != ""x ] ; then
    CUR_BOOT_PARTITION="/dev/block/by-name/boot${CUR_SLOT}"

    CUR_SHA1="$( ${ADB} ${ADB_OPTIONS} shell /data/adb/magisk/magiskboot sha1 ${CUR_BOOT_PARTITION} )"
    if [ "${CUR_SHA1}"x != ""x  ] ; then
      CUR_BACKUP_DIR="/data/magisk_backup_${CUR_SHA1}"

      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${MAGISKBOOT} mkdir -p "${CUR_BACKUP_DIR}" )"
      TEMPRC=$?
      if [ ${TEMPRC} = 0 ] ; then
        CUR_BOOT_IMG_FILE="${CUR_BACKUP_DIR}/boot.img.gz" 
        
        LogMsg "Creating a backup of the original boot partition \"${CUR_BOOT_PARTITION}\" in the file \"${CUR_BOOT_IMG_FILE}\" ..."
        
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell "dd if=\"${CUR_BOOT_PARTITION}\" | gzip -c  >\"${CUR_BOOT_IMG_FILE}\" "  )"
        TEMPRC=$?
        if [ ${TEMPRC} = 0 ] ; then
          LogMsg " ... backup file \"${CUR_BOOT_IMG_FILE}\" successfully created"
          THISRC=${__TRUE}
        else
          LogMsg "-" "${CUR_OUTPUT}"
          LogErrorMsg "Error creating the backup file \"${CUR_BOOT_IMG_FILE}\" " 
          THISRC=${__FALSE}
        fi
      fi                  
    fi
  fi
  
  return ${THISRC}
}


# ----------------------------------------------------------------------
# convert the slot to use into _a or _b
#
# Usage: get_slot_for_this_task [slot_to_use]
#
# returns: ${__TRUE} - slot to use written to STDOUT
#          ${__FALSE} - empty string written to STDOUT
#
# Note:
#
#  The global variable BOOT_SLOT must contain the name of the current active slot (either _a or -b)
#
function get_slot_for_this_task {
  typeset __FUNCTION="get_slot_for_this_task"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__FALSE}
   
  typeset SLOT_FOR_THIS_TASK="$1"

  if [ "${BOOT_SLOT}"x != ""x ] ; then

    case ${SLOT_FOR_THIS_TASK} in
      _a | _b )
        ;;
      
      next | inactive )
        [ "${BOOT_SLOT}" = "_b" ] && SLOT_FOR_THIS_TASK="_a" || SLOT_FOR_THIS_TASK="_b"
        ;;
        
      current | active  )
        SLOT_FOR_THIS_TASK="${BOOT_SLOT}"
        ;;
      
    esac
 
    printf "${SLOT_FOR_THIS_TASK}"
    THISRC=${__TRUE}

  else
    printf ""    
    THISRC=${__FALSE}
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# convert a time value into seconds
#
# Usage: convert_to_seconds [value[h|H|m|M|s|S]]
#
# returns: ${__TRUE} - time converted to seconds
#          ${__FALSE} - error converting the parameter
#
# The converted time in seconds is written to STDOUT
#
#
function convert_to_seconds {
  typeset __FUNCTION="convert_to_seconds"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__FALSE}
  
  typeset TIME_IN_SECONDS=""
  typeset CUR_PARAMETER="$1"
  typeset CUR_FACTOR=1
  
  if [ $# -eq 1 ] ; then
    case ${CUR_PARAMETER} in
      *h  )
          CUR_PARAMETER=${CUR_PARAMETER%*h}
          FACTOR=3600
          ;;
  
      *H  )
          CUR_PARAMETER=${CUR_PARAMETER%*H}
          FACTOR=3600
          ;;
  
      *m  )
          CUR_PARAMETER=${CUR_PARAMETER%*m}
          FACTOR=60
          ;;
  
      *M  )
          CUR_PARAMETER=${CUR_PARAMETER%*M}
          FACTOR=60
          ;;
    
      *s  )
          CUR_PARAMETER=${CUR_PARAMETER%*s}
          FACTOR=1
          ;;
  
      *S  )
          CUR_PARAMETER=${CUR_PARAMETER%*S}
          FACTOR=1
          ;;
  
      *  )
          CUR_PARAMETER=${CUR_PARAMETER}
          FACTOR=1
          ;;
  
    esac
  fi
  
  if isNumber ${CUR_PARAMETER} ; then
    (( TIME_IN_SECONDS = CUR_PARAMETER * FACTOR ))
 
    printf "${TIME_IN_SECONDS}"
    THISRC=${__TRUE}
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# wait_some_seconds
#
# function: wait n seconds
#
# Usage: wait_some_seconds [number_of_seconds]
#
# returns: ${__TRUE}  - waited n seconds
#          ${__FALSE} - no parameter found, to many parameter found,
#                       or the parameter is not a number
#
typeset -f wait_some_seconds >>/dev/null || function wait_some_seconds {
  typeset THISRC=${__FALSE}

  typeset WAIT_TIME_IN_SECONDS="$1"
  typeset i=0
  
  if [ $# -eq 1 ] ; then
    if isNumber ${WAIT_TIME_IN_SECONDS} ; then
#      LogMsg "[$( date "+%Y.%m.%d %H:%M:%S")] Waiting now ${WAIT_TIME_IN_SECONDS} seconds ..."
      LogMsg "Waiting now ${WAIT_TIME_IN_SECONDS} seconds ..."
     
      while [ $i -lt ${WAIT_TIME_IN_SECONDS} ] ; do
        (( i = i + 1 ))
        printf "."
        sleep 1
      done
      printf "\n"
      THISRC=${__TRUE}
    fi
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# define the function init_tasks
#
# this function is executed once before the tasks are executed
#
function init_tasks {
  typeset __FUNCTION="init_tasks"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  LogInfo "*** ${__FUNCTION}: Started  "
  
  typeset THISRC=${__TRUE}
  typeset TEMPRC=""

  typeset i=0

  typeset CUR_PARAMETER=""
  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""
  
  typeset INIT_TASKS_ONLY=${__FALSE}
  typeset INIT_TASKS_IN_VERBOSE_MODE=${__FALSE}
  typeset INIT_TASKS_WITH_TRACE=${__FALSE}
  
  typeset GLOBAL_VERBOSE_MODE="${VERBOSE}"

  typeset TMPFILE=""

  typeset CHECK_THE_PHONE_STATUS=${__TRUE}

  typeset LIST_DEFAULT_VALUES_ONLY=${__FALSE}
  
  typeset CUR_FILE=""

  typeset LIST_OF_SUPPORTED_ENV_VARIABLES=""
  typeset CUR_VAR=""
  typeset CUR_VALUE=""

  typeset CONFIG_FILE_READ=${__FALSE}
  
  [[ " $* " == *\ trace\ * ]] && set -x
  
# global variables (also used by the scripts executed in the tasks)
#
  export REBOOT="no"

  export PATH=$PATH:/sbin:/usr/sbin:/bin/:/usr/bin

  ABORT_TASK_EXECUTION_ON_ERROR=${__TRUE}

  TASKS_EXECUTED_WITH_IGNORED_ERROR=""
  NO_TASKS_EXECUTED_WITH_IGNORED_ERROR=0

#
# read the config file if it exists
#
  if [ "${PREPARE_PHONE_CONFIG_FILE_NAME}"x = "none"x ] ; then
    LogMsg "Using of a config file is disabled."
  else
    LogMsg "Searching for a config file ...."
    for CUR_FILE in ${PREPARE_PHONE_CONFIG_FILE_NAME} ${HOME}/${PREPARE_PHONE_CONFIG_FILE_NAME} /etc/${PREPARE_PHONE_CONFIG_FILE_NAME}; do

      tryIncludeScript "${CUR_FILE}"

# get the list of variables defined in the config file
#
      NEW_VARS="$( ${EGREP} -v "^#|^$" "${CUR_FILE}" | ${EGREP} "^[a-zA-Z0-9_]*=" | cut -f1 -d "=" )"

      if [ ${__INCLUDE_SCRIPT_RC} -eq 1 ] ; then
        LogInfo "The config file \"${CUR_FILE}\" does not exist "
        continue
      elif [ ${__INCLUDE_SCRIPT_RC} -eq 2 ] ; then
        LogErrorMsg "There are syntax errors in the config file  \"${CUR_FILE}\"  "
        THISRC=${__FALSE}
        break
      elif [ ${__INCLUDE_SCRIPT_RC} -eq 0 ] ; then
        LogMsg "Config file \"${CUR_FILE}\" succesfully read "
        
        LogInfo "New variables defined in the file \"${CUR_FILE}\" are: " && \
          LogMsg "-" "${NEW_VARS}"

# export all variables defined in the config file
#
        export ${NEW_VARS}

        CONFIG_FILE_READ=${__TRUE}
        break
      fi
    done
  fi

  if [ ${CONFIG_FILE_READ} != ${__TRUE} ] ; then
    LogMsg "No config file found"
  fi
  
# Magisk App apk file to use
#
  MAGISK_APK_FILE="${MAGISK_APK_FILE:=${DEFAULT_MAGISK_APK_FILE}}"


# parameter for the function init_tasks
#
  if [ "${PARAMETER_FOR_INIT_TASKS}"x != ""x ] ; then
    LogInfo "The parameter for the function ${__FUNCTION} are: \"${PARAMETER_FOR_INIT_TASKS}\" "
    
    set -- ${PARAMETER_FOR_INIT_TASKS}
    while [ $# -ne 0 ] ; do

      CUR_PARAMETER="$1"
      shift

      PARAMETER_KEY="${CUR_PARAMETER%%:*}"
      PARAMETER_VAL="${CUR_PARAMETER#*:}"
      [ "${PARAMETER_VAL}"x = "${PARAMETER_KEY}"x ] && PARAMETER_VAL=""

      case ${PARAMETER_KEY} in

        help )
          ksh "${CUR_INCLUDE_FILE}" --help
          die 0
          ;;

        list_defaults )
          LIST_DEFAULT_VALUES_ONLY=${__TRUE}
          ;;

        init_tasks_only | init_only )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- ends the script after exectuing \"init_tasks\" "
          INIT_TASKS_ONLY=${__TRUE}
          ;;

        no_init_tasks_only | no_init_only )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- does NOT end the script after exectuing \"init_tasks\" "
          INIT_TASKS_ONLY=${__TRUE}
          ;;

        trace )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- executes \"init_tasks\" in trace mode"
          INIT_TASKS_WITH_TRACE=${__TRUE}
          ;;

        notrace | no_trace)
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- does NOT execute \"init_tasks\" in trace mode"
          INIT_TASKS_WITH_TRACE=${__FALSE}
          ;;
        
        verbose )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- executes \"init_tasks\" in verbose mode"
          INIT_TASKS_IN_VERBOSE_MODE=${__TRUE}
          ;;

        noverbose | no_verbose )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- does NOT execute \"init_tasks\" in verbose mode"
          INIT_TASKS_IN_VERBOSE_MODE=${__TRUE}
          ;;
          
        nostatusfile | nostatus | no_status | no_statusfile )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- Status file disabled via init_tasks parameter"
          CHECK_STATUS_FILE=""
          ;;
        
        statusfile )
          if [ "${PARAMETER_VAL}"x = "none"x ] ; then
            LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- Status file disabled via init_tasks parameter"
            CHECK_STATUS_FILE=""
          else
            CHECK_STATUS_FILE="${PARAMETER_VAL}"
            LogMsg "${__FUNCTION}: Status file found in the parameter is \"${CHECK_STATUS_FILE}\" "                
          fi
          ;;

        dryrun | dry-run )
          if [ "${PARAMETER_VAL}"x = "none"x ] ; then
            LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- dry-run mode is now disabled"
          
            PREFIX_FOR_THE_COMMANDS=""
          elif [ "${PARAMETER_VAL}"x != ""x ] ; then
            PREFIX_FOR_THE_COMMANDS="${PARAMETER_VAL}"
            LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- dry-run mode is now enabled using the prefix \"${PREFIX_FOR_THE_COMMANDS}\""
          else
            PREFIX_FOR_THE_COMMANDS="${DRYRUN_PREFIX}"
            LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- dry-run mode is now enabled using the prefix \"${PREFIX_FOR_THE_COMMANDS}\""
          fi
          ;;

        nodryrun | no-dry-run | nodry-run )
          LogMsg "${__FUNCTION}: parameter \"${CUR_PARAMETER}\" found -- dry-run mode is now disabled"
          PREFIX_FOR_THE_COMMANDS=""
          ;;

        nophonecheck )
          CHECK_THE_PHONE_STATUS=${__FALSE}
          ;;

        phonecheck )
          CHECK_THE_PHONE_STATUS=${__TRUE}
          ;;

        * )
          LogWarningMsg "${__FUNCTION}: Unknown parameter for \"${__FUNCTION}\" found: \"${CUR_PARAMETER}\" "
          ;;

      esac
    done
    
  else
    LogInfo "No parameter for the function ${__FUNCTION} defined "
  fi

  if [ ${LIST_DEFAULT_VALUES_ONLY} = ${__TRUE} ] ; then
     LogMsg "-" "
Environment variables that can be defined before starting the script are:
"
    LIST_OF_SUPPORTED_ENV_VARIABLES="$( grep "^DEFAULT"    ${CUR_INCLUDE_FILE} | grep -v "DEFAULT_TASKS=" | cut -f2- -d"_"  | cut -f1 -d "=" )"
    for CUR_VAR in ${LIST_OF_SUPPORTED_ENV_VARIABLES} ; do
      eval CUR_VALUE="\$${CUR_VAR}"
      echo "${CUR_VAR}=${CUR_VALUE}"
    done

    die 0
  fi
  
  if [ "${PREFIX_FOR_THE_COMMANDS}"x != ""x ] ; then
    LogMsg "Running in dry-run mode -- the used prefix for the commands is: ${PREFIX_FOR_THE_COMMANDS}"
  fi
  
  if [ ${INIT_TASKS_IN_VERBOSE_MODE} = ${__TRUE} ] ; then
    LogMsg "Enabling verbose mode for the function \"${__FUNCTION}\" ..."
    VERBOSE=${__TRUE}
  fi

  if [ ${INIT_TASKS_WITH_TRACE} = ${__TRUE} ] ; then
    LogMsg "Enabling trace for the function \"${__FUNCTION}\" ..."
    set -x
  fi
   

  if [ "${TMP}"x != ""x ] ; then
    if [ ! -d "${TMP}" ] ; then
      LogWarningMsg "The directory \"${TMP}\" defined in the variable TMP does NOT exist -- now trying to use the default directory for temporary files: /tmp"
      TMP="/tmp"
      if [ ! -d "${TMP}" ] ; then 
        die 201 "The directory \"${TMP}\" does not exist"
      fi
    fi
  else
    TMP="/tmp"    
  fi
  LogMsg "Using the directory \"${TMP}\" for temporary files"

  typeset TMPFILE="${TMP}/${__FUNCTION}_$$.sh"
  FILES_TO_REMOVE="${FILES_TO_REMOVE} ${TMPFILE}"


# add a cleanup function for the housekeeping
# (the standard house keeping function can not be used for all tasks if the script is executed by a non-root user)
#
  CUR_MOUNTS_TO_UMOUNT=""
  CLEANUP_FUNCTIONS="${CLEANUP_FUNCTIONS} mycleanup"

  CUR_INCLUDE_FILE_UPDATE_DATE="$( grep "^#H#" "${CUR_INCLUDE_FILE}" | ${EGREP} "[0-9[0-9]\.[0-9][0-9][0-9][0-9]" | tail -1 | cut -f2- -d " "  | tr -s " " )"
  CUR_INCLUDE_FILE_UPDATE_DATE="$( echo ${CUR_INCLUDE_FILE_UPDATE_DATE} )"
  CUR_INCLUDE_FILE_LS="$( ls -l "${CUR_INCLUDE_FILE}"  )"

  LogMsg "The PID of this process is $$"

  LogMsg "The include file used is :"
  LogMsg "-" "${CUR_INCLUDE_FILE_LS}"
  LogMsg "The include file used was last edited at: \"${CUR_INCLUDE_FILE_UPDATE_DATE}\" "
  LogMsg "The version of the used execute_tasks.sh script is \"${SCRIPT_VERSION}\" "
  LogMsg "-" "-----------------------------------------------------------------------"

  [ "${TWRP_IMAGE}"x != ""x ] && LogMsg "Using the TWRP image \"${TWRP_IMAGE}\" for booting the phone into TWRP"

# save the default TWRP image name if not already done in the file prepare_phone.conf
#
  if [ "${DEFAULT_TWRP_IMAGE}"x = ""x ] ; then
    LogMsg "Variable \"DEFAULT_TWRP_IMAGE\" neither set in the config file \"prepare_phone.conf\" nor in the environment - setting the variable now to \"${TWRP_IMAGE}\" "
    DEFAULT_TWRP_IMAGE="${TWRP_IMAGE}"
  fi
  
# ----------------------------------------------------------------------

  if  [ "${WORKDIR}"x != ""x ] ; then
    LogInfo "Using the work directory defined in the variable \"\${WORKDIR}\" : \"${WORKDIR}\" "
    WORKDIR_SET_BY_THE_USER=${__TRUE}
  else
    WORKDIR="${TMP}/${SCRIPTNAME}_WORKDIR.$$"
    WORKDIR_SET_BY_THE_USER=${__FALSE}
  fi

  mkdir -p "${WORKDIR}" && cd "${WORKDIR}"
  if [ $? -ne 0 ] ; then
    if [ ${WORKDIR_SET_BY_THE_USER} = ${__TRUE} ] ; then
      die 200 "Can not use the working directory requested by the user: \"${WORKDIR}\" "
      THISRC=${__FALSE}
    else
      LogWarningMsg "Can not use the working directory \"${WORKDIR}\" - using \"${TMP}\" instead "
      WORKDIR="${TMP}"
      cd "${WORKDIR}"
      if [ $? -ne 0 ] ; then
        LogErrorMsg "Can not change the working directory to \"${WORKDIR}\" "
        THISRC=${__FALSE}
      fi
    fi
  else
    LogMsg "Using the working directory \"${WORKDIR}\" ."
  fi
  LogMsg "-"


# ----------------------------------------------------------------------
# check the prerequistes
#
  if [ ! -d "${SCRIPT_DIR}" ] ;then
    LogErrorMsg "The script directory \"${SCRIPT_DIR}\" does not exist"
    THISRC=5
  fi

  if [ ! -r "${PHONE_FUNCTIONS_INCLUDE_FILE}" ] ; then
    LogErrorMsg "The include file \"${PHONE_FUNCTIONS_INCLUDE_FILE}\" does not exist"
    THISRC=15
  fi


# disable the initializating code in the include file
#
  EXECUTE_BOOT_PHONE_FROM_TWRP_INIT=${__FALSE}

  LogMsg "*** Reading the include file \"${PHONE_FUNCTIONS_INCLUDE_FILE}\" ..."
  . "${PHONE_FUNCTIONS_INCLUDE_FILE}"

#
# fastboot mus be executed by the user root -> use sudo if the script is executed by a non-root user
# (This is only necessary if the udev rules are incomplete)
#
  if [ "${SUDO_PREFIX}"x = ""x ] ; then
    CUR_USER="$( whoami )"
    if [ "${CUR_USER}"x != "root"x ] ; then
      SUDO_PREFIX="sudo"
      LogMsg "The script is running as user \"${CUR_USER}\" -- using \"${SUDO_PREFIX}\" for the fastboot commands ..."
    else
      SUDO_PREFIX=""
    fi
  fi

  get_usb_device_for_the_phone 

# read the serial number of the attached phone if the variable SERIAL_NUMBER is not already set
#
  set_serial_number 
  if [ "${SERIAL_NUMBER}"x = ""x ] ; then
    LogMsg "No attached phone found -- resetting the USB port used for the phone now ..."
    reset_the_usb_port_for_the_phone

# read the serial number of the attached phone again after doing the USB port reset
#
    set_serial_number
  fi
  
  init_global_vars_for_boot_phone_from_twrp 
  
  check_prereqs_for_boot_phone_from_twrp || die 112 "One or more errors in the prereq found"
  
  if [ ${CHECK_THE_PHONE_STATUS} = ${__TRUE} ] ; then

    PHONE_STATUS=99
    retrieve_phone_status ${__FALSE}
    TEMPRC=$?

    if [ ${PHONE_STATUS} -ge 10 ] ; then
      LogErrorMsg "Error retrieving the status of the attached phone (RC=${TEMPRC})"
      LogMsg "Use the init_task parameter \" -- nophonecheck \" to suppress this check"
      THISRC=10    
    fi    
  else
    LogWarningMsg "The check of the phone status init_tasks is disabled"    
  fi

# ----------------------------------------------------------------------

# variable only used to define the TWRP image to use for the next reboot after the OS installation
#
  export TWRP_IMAGE_FOR_NEW_OS=""

# ----------------------------------------------------------------------

  if [ ${INIT_TASKS_ONLY} = ${__TRUE} ] ; then
    LogMsg "Only executing the function \"init_tasks\" requested -- the script ends now"
    THISRC=1
  fi

# ----------------------------------------------------------------------
# restore the global verbose mode
#
  VERBOSE="${GLOBAL_VERBOSE_MODE}"

  LogInfo "*** ${__FUNCTION}: Ended  "

  return ${THISRC}

}

# ----------------------------------------------------------------------
# define the function finish_tasks (optional)
#
# this function is executed once after the tasks are executed
#
function finish_tasks {
  typeset __FUNCTION="finish_tasks"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  LogInfo "*** ${__FUNCTION}: Started  "

  typeset THISRC=${__TRUE}

  typeset CUR_TASK=""

  typeset SEPARATOR="-------------------------------------------------------------------------------------------------------------"

#  LogMsg "This is the function \"${__FUNCTION#task_*}\"  "

  LogMsg "-"
  LogMsg "-" "${SEPARATOR}"
  LogMsg "*** Task summary :"
  LogMsg "-"

  if [ "${TASKS_SUCCESSFULLY_CHECKED}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Tasks executed successfully are:"
    
    TASKS_SUCCESSFULLY_CHECKED="$( echo "${TASKS_SUCCESSFULLY_CHECKED}" | tr " " "\n" | sort | uniq )"

    for CUR_TASK in ${TASKS_SUCCESSFULLY_CHECKED} ; do
      LogMsg "-" "${CUR_TASK}"
    done
    LogMsg "-"
  fi

  if [ "${TASKS_WITH_ERRORS}"x != ""x ] ; then

    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Tasks executed with errors are:"

    TASKS_WITH_ERRORS="$( echo "${TASKS_WITH_ERRORS}" | tr " " "\n" | sort | uniq )"

    for CUR_TASK in ${TASKS_WITH_ERRORS} ; do
      LogMsg "-" "${CUR_TASK}"
    done
    LogMsg "-"
  fi

  if [ "${TASKS_EXECUTED_WITH_IGNORED_ERROR}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "${NO_TASKS_EXECUTED_WITH_IGNORED_ERROR} task(s) executed with ignored errors:"
    
    TASKS_EXECUTED_WITH_IGNORED_ERROR="$( echo "${TASKS_EXECUTED_WITH_IGNORED_ERROR}" | tr " " "\n" | sort | uniq )"
    
    for CUR_TASK in ${TASKS_EXECUTED_WITH_IGNORED_ERROR} ; do
      LogMsg "-" "${CUR_TASK}"
    done
    LogMsg "-"
  fi

  if [ "${TASKS_TO_CHECK_MANUALLY}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Tasks that must be checked manually:"
    LogMsg "-"
    LogMsg "-" "${TASKS_TO_CHECK_MANUALLY}"
    LogMsg "-"
  fi

  if [ "${WARNING_MESSAGES}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Important Warning messages from all tasks"
    LogMsg "-"
    LogMsg "-" "${WARNING_MESSAGES}"
  fi


  if [ "${ERROR_MESSAGES}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Error messages from all tasks"
    LogMsg "-"
    LogMsg "-" "${ERROR_MESSAGES}"
  fi


  if [ "${COMMAND_HINTS}"x != ""x ] ; then
    LogMsg "-"
    LogMsg "-" "${SEPARATOR}"
    LogMsg "Commands to fix some of the issues found"
    LogMsg "-"
    LogMsg "-" "${COMMAND_HINTS}"
    LogMsg "-"
  fi

  LogMsg "-" "${SEPARATOR}"
  LogMsg "-"
  LogMsg "The working directory used is: \"${WORKDIR}\" ."
  LogMsg "-"
  
  LogMsg "-"
  
  if  [ "${CHECK_STATUS_FILE}"x != ""x -a "${TASKS_WITH_ERRORS}"x != ""x ] ; then
    LogMsg "Writing the list of failed tasks to the file \"${CHECK_STATUS_FILE}\" ..."
    CUR_OUTPUT="$( (  echo "${TASKS_WITH_ERRORS}" | tr " " "\n" >"${CHECK_STATUS_FILE}" ) 2>&1 )"
    if [ $? -ne 0 ] ; then
      LogMsg "-" "${CUR_OUTPUT}"
      LogErrorMsg "Error writing the list of failed tasks to the file \"${CHECK_STATUS_FILE}\" ..."
    fi
  fi

  LogMsg "The include file used was :"
  LogMsg "  ${CUR_INCLUDE_FILE_LS}"
  LogMsg "The include file used was last edited at: \"${CUR_INCLUDE_FILE_UPDATE_DATE}\" "
  
  LogInfo "*** ${__FUNCTION}: Ended  "

  return ${THISRC}
}

# ----------------------------------------------------------------------
#
function mycleanup {
  typeset __FUNCTION="mycleanup"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__TRUE}
  typeset CUR_MOUNT=""

  LogInfo "*** ${__FUNCTION}: Started  "

  for CUR_MOUNT in ${CUR_MOUNTS_TO_UMOUNT} ; do
    LogInfo "${__FUNCTION}: umount ${CUR_MOUNT} "
    ${PREFIX_FOR_THE_COMMANDS} umount ${CUR_MOUNT} 2>/dev/null 1>/dev/null
  done

  LogInfo "*** ${__FUNCTION}: Ended  "

  return ${THISRC}
}
  

# ----------------------------------------------------------------------
# helper functions
#

# log an error message and store the message in the global list of error messages
#
function LogErrorMsg {
  typeset __FUNCTION="LogErrorMsg"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__TRUE}

  LogError "$*"

  ERROR_MESSAGES="${ERROR_MESSAGES}
$*"

  return ${THISRC}
}

# log an warning message and store the message in the global list of warning messages
#
function LogWarningMsg {
  typeset __FUNCTION="LogWarningMsg"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__TRUE}

  LogWarning "$*"

  WARNING_MESSAGES="${WARNING_MESSAGES}
$*"

  return ${THISRC}
}


# ----------------------------------------------------------------------
# wait_for_working_adb_connection
#
# function: wait for a working adb connection
#
# usage: wait_for_working_adb_connection
#
# returns: ${__TRUE} - working adb connection found
#
function wait_for_working_adb_connection {
  typeset __FUNCTION="wait_for_working_adb_connection"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__FALSE}

  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  
  LogMsg "Waiting for the phone ..."
  timeout 120 ${ADB} ${ADB_OPTIONS} wait-for-device

  CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"    
  TEMPRC=$?
  
  LogInfo "${__FUNCTION}: Output of the adb command :" && \
    LogMsg "-" "${CUR_OUTPUT}"
  
  if [ ${TEMPRC} -eq 0 ]  ; then      
    THISRC=${__TRUE}
  else
    if [[ ${CUR_OUTPUT} == *insufficient\ permissions\ for\ device* ]] ; then
      LogMsg "-" "${CUR_OUTPUT}"

      LogMsg "Permission problem - killing the adb daemon now ..."
      pkill adb
      ps -ef | grep adb

      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"
      TEMPRC=$?
  
      LogInfo "${__FUNCTION}: Output of the 2nd adb command :" && \
        LogMsg "-" "${CUR_OUTPUT}"
      if [ ${TEMPRC} -eq 0 ]  ; then      
        THISRC=${__TRUE}
      fi
    fi
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# wait_until_sdcard_is_mounted
#
# function: wait up to n seconds until /sdcard is mounted
#
# usage: wait_until_sdcard_is_mounted [wait_time_in_seconds]
#
# returns: ${__TRUE} - working adb connection found
#
function wait_until_sdcard_is_mounted {
  typeset __FUNCTION="wait_until_sdcard_is_mounted"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__TRUE}

  typeset CUR_OUTPUT=""
  typeset TEMPRC=""
  
  typeset WAIT_TIME="$1"

  typeset DEFAULT_WAIT_TIME=30
  typeset i=0
  
  [ "${WAIT_TIME}"x = ""x ] && WAIT_TIME=${DEFAULT_WAIT_TIME}
  
  if ! isNumber ${WAIT_TIME} ; then
    LogWarningMsg "${__FUNCTION}: The value \"${WAIT_TIME}\" is not a number -- using the default value (${DEFAULT_WAIT_TIME} seconds) now"
    WAIT_TIME=${DEFAULT_WAIT_TIME}
  fi

  LogMsg "Waiting up to ${WAIT_TIME} seconds until /sdcard is mounted ..."
  timeout 120 ${ADB} ${ADB_OPTIONS} wait-for-device
  
  while [ $i -lt ${WAIT_TIME} ] ; do 
    (( i = i + 1 ))
    ${ADB} ${ADB_OPTIONS} shell test -d /sdcard/Download  && break
    printf "."
    sleep 1
  done
  printf "\n"
  
  if [ -d /sdcard/Download ] ; then
    LogErrorMsg "${__FUNCTION}: /sdcard is not mounted after ${i} seconds"
    THISRC=${__FALSE}
  else
    LogMsg "${__FUNCTION}: /sdcard is mounted after ${i} second(s)"      
  fi
  
  return ${THISRC}
}


# ----------------------------------------------------------------------
# check_root_access
#
# function: check if there is a working root access via adb
#
# usage: check_root_access [silent]
#
# returns: ${__TRUE}  - root access via adb works; ROOT_ACCESS_PREFIX is defined if necessary
#          ${__FALSE} - root access via adb does not work; kROOT_ACCESS_PREFIX is empty
#
# The function sets the global variable ROOT_ACCESS_PREFIX with the necessary prefix for executing commands as root user
#
function check_root_access {
  typeset __FUNCTION="check_root_access"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__FALSE}

  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset CUR_PARAMETER="$1"
  
# global variable
#  
  ROOT_ACCESS_PREFIX=""

  CUR_OUTPUT="$( timeout 120 ${ADB} ${ADB_OPTIONS} shell id -un  2>&1 )"
  if [ "${CUR_OUTPUT}"x = "root"x ] ; then
    LogMsg "root access without \"su\" is enabled on the phone"
    THISRC=${__TRUE}
  fi
  
  while [ ${THISRC} = ${__FALSE} ] ; do

    CUR_OUTPUT="$( timeout 120 ${ADB} ${ADB_OPTIONS} shell su - -c id  2>&1 )"
    TEMPRC=$?

    LogInfo "${__FUNCTION}: Output of the adb command to check the root access is :" && \
      LogMsg "-" "${CUR_OUTPUT}"

    if [ ${TEMPRC} = 0 ] ; then
      ROOT_ACCESS_PREFIX="su - -c "
      THISRC=${__TRUE}
      break
    fi
    
    if [ "${CUR_PARAMETER}"x != "silent"x ] ; then
      AskUser "*** Root access to the phone via adb does NOT work - please fix and enter y<return>\ to try again" 
      if [ $? -ne ${__TRUE} ] ; then
        LogMsg "Root access to the phone does not work"
        THISRC=${__FALSE}
      
        break
      else
        LogMsg "root access via \"su -\" is enabled on the phone"
      fi
    else
      break
    fi
  done
     
  return ${THISRC}
}


# ----------------------------------------------------------------------
# execute_script
#
# function: execute a script
#
# usage: execute_script [script] [parameter_for_the_script]
#
# returns: ${__TRUE} - the script ends with a return code 0
#          ${__FALSE} - the script ends with a return code not 0
#
# The return code of the script is stored in the global variable SCRIPT_RC
#
function execute_script {
  typeset __FUNCTION="execute_script"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=""

  typeset CUR_OUTPUT=""
  typeset THISRC=""
  
  typeset DO_IT=${__TRUE}
 
  typeset THIS_SCRIPT="$1"
  [ $# -ne 0 ] && shift
  typeset THIS_PARAMETER="$*"

  typeset NEW_TWRP_IMAGE=""
  typeset NEW_IWRP_IMAGE_FILE_TYPE=""
  
  typeset CUR_COMMAND=""
  
  typeset SINGLE_STEP_MESSAGE_OPTIONS=""
  typeset SINGLE_STEP_MESSAGE=""
  
  LogMsg "-"
  LogMsg " ---------------------------------------------------------------------- "  

# clear the global variable
#  
  SCRIPT_RC=""
#
# check if the script exists
#  
  if [ ! -r "${THIS_SCRIPT}" ] ; then
    LogErrorMsg "The script \"${THIS_SCRIPT}\" does not exist"
    THISRC=""
  elif [ ! -x "${THIS_SCRIPT}" ] ; then
    LogErrorMsg "The script \"${THIS_SCRIPT}\" is not executable"
    THISRC=""
  else
#
# execute the script
#
    while [ "${THIS_SCRIPT}"x != ""x ] ; do
      if [ ${DO_IT} = ${__TRUE} ] ; then
        
        LogMsg "-"
        LogMsg "*** Executing now \"${THIS_SCRIPT} ${THIS_PARAMETER}\" ..."
        LogMsg "-" "# ---------------------------------------------------------------------"
        LogMsg "-"
        
        executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${THIS_SCRIPT} ${THIS_PARAMETER}
        SCRIPT_RC=$?
        
        if [ ${SCRIPT_RC} = 0 ] ; then
          THISRC=${__TRUE} 
        elif [ ${IGNORE_SCRIPT_RC} != ${__TRUE} ] ; then
          THISRC=${__FALSE}
        else
          THISRC=${__TRUE} 
        fi
                
        LogMsg "-"
        LogMsg "-" "# ---------------------------------------------------------------------"

        LogMsg " ... the script ended with RC=${SCRIPT_RC}"

        DO_IT=${__FALSE}
      fi
        
      if [ ${THISRC} = ${__TRUE} ] ; then
        break
      fi

      SINGLE_STEP_MESSAGE=""
      SINGLE_STEP_MESSAGE_OPTIONS=""
      
      if [ "${SINGLE_STEP_MODE}"x != ""x ] ; then

        if [ ${SINGLE_STEP_MODE} = ${__FALSE} ] ; then
          SINGLE_STEP_MESSAGE="${SINGLE_STEP_MESSAGE}
Single Step mode is currently disabled"         

          SINGLE_STEP_MESSAGE_OPTIONS="${SINGLE_STEP_MESSAGE_OPTIONS}
s singlestep     - enable single step mode"

        else
           SINGLE_STEP_MESSAGE="${SINGLE_STEP_MESSAGE}
Single Step mode is currently enabled"         

        SINGLE_STEP_MESSAGE_OPTIONS="${SINGLE_STEP_MESSAGE_OPTIONS}
s singlestep     - disable single step mode"

        fi
      fi
      
      if [ "${ENABLE_SINGLE_STEP_ON_ERROR}"x != ""x ] ; then

        if [ ${ENABLE_SINGLE_STEP_ON_ERROR} = ${__FALSE} ] ; then
          SINGLE_STEP_MESSAGE="${SINGLE_STEP_MESSAGE}
Single Step mode on error is currently disabled"         
  
        SINGLE_STEP_MESSAGE_OPTIONS="${SINGLE_STEP_MESSAGE_OPTIONS}
e on_error       - enable single step mode after the next task fails"

        else
          SINGLE_STEP_MESSAGE="${SINGLE_STEP_MESSAGE}
Single Step mode on error is currently enabled"         

          SINGLE_STEP_MESSAGE_OPTIONS="${SINGLE_STEP_MESSAGE_OPTIONS}
e on_error       - disable single step mode after the next task fails"

        fi
      fi
           
      LogMsg "-" "
The execution of the script \"${THIS_SCRIPT}\" with the parameter \"${THIS_PARAMETER}\" in the task \"${CUR_TASK#task_*}\" ended with RC=${SCRIPT_RC} 
${SINGLE_STEP_MESSAGE}
Select wwhat to do next

r y repeat       - Repeat the task
c cont continue  - continue with the next task
${SINGLE_STEP_MESSAGE_OPTIONS}
k kill           - kill the adb daemon
t twrp           - change the TWRP image to use
R reset_usb      - reset the USB port for the  phone
f format         - format /data
m mount          - mount /data
S status         - retrieve, update, and print the phone status
shell            - open a shell
!cmd             - execute the command \"cmd\"

quit             - end the script

"
      AskUser "Your choice [default=repeat) >> " 
      if [ $? -eq 0 ] ; then
        DO_IT=${__TRUE}
#        THISRC=0
#        break
      else

        TASKS_EXECUTED_WITH_ERRORS="${TASKS_EXECUTED_WITH_ERRORS} ${CUR_TASK#task_*}"
      
        case ${USER_INPUT} in

          s | singlestep )
            ENABLE_SINGLE_STEP_ON_ERROR=${__FALSE}
            if [ ${SINGLE_STEP_MODE} = ${__FALSE} ] ; then
              LogMsg "Enabling single step mode now"
              SINGLE_STEP_MODE=${__TRUE}
            else
              LogMsg "Disabling single step mode now"
              SINGLE_STEP_MODE=${__FALSE}
            fi
            ;;
          
          on_error | e )
            SINGLE_STEP_MODE=${__FALSE}
            if [ ${ENABLE_SINGLE_STEP_ON_ERROR} = ${__FALSE} ] ; then
              LogMsg "Enabling single step on error now"
              ENABLE_SINGLE_STEP_ON_ERROR=${__TRUE}
            else
              LogMsg "Disabling single step on error now"
              ENABLE_SINGLE_STEP_ON_ERROR=${__FALSE}
            fi
            ;;

          f | format )
            LogMsg "Formating /data ..."
            CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell twrp format data  2>&1  )"
            LogMsg "-" "${CUR_OUTPUT}"
            ;;

          m  | mount  )
            LogMsg "Formating /data ..."
            CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell twrp mount data 2>&1 )"
            LogMsg "-" "${CUR_OUTPUT}"            
            ;;
           
          fm )
            LogMsg "Formating and mounting /data ..."
            CUR_OUTPUT="$( exec 2>&1; set -x ; ${ADB} ${ADB_OPTIONS} shell twrp format data ; ${ADB} ${ADB_OPTIONS} shell twrp mount data )"
            LogMsg "-" "${CUR_OUTPUT}"            
            ;;

          k | K | kill ) 
            LogMsg "Running adb daemons are:"
            CUR_OUTPUT="$( ps -ef  | grep -v grep | grep adb )" 
            LogMsg "-" "${CUR_OUTPUT}"
            
            LogMsg "-"
            LogMsg "Killing the adb deamon now ..."
            CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} kill-server 2>&1 )"
            LogMsg "-" "${CUR_OUTPUT}"

            LogMsg "-"
            LogMsg "Running adb daemons are now:"
            CUR_OUTPUT="$( ps -ef  | grep -v grep | grep adb )" 
            LogMsg "-" "${CUR_OUTPUT}"
            LogMsg "-"
            ;;

          S | status )
            LogMsg "Retrieving the status of the phone ..."
            retrieve_phone_status
            print_phone_status
            ;;

          r  | repeat | "" )
            retrieve_phone_status
            DO_IT=${__TRUE}
            ;;
    
          c | C | continue | cont ) 
            retrieve_phone_status
            THISRC=0
            break
            ;;
          
          R | reset_usb )
            LogMsg "The list of known adb devices is now:"
            CUR_OUTPUT="$( adb devices 2>&1 )"
            LogMsg "-"
            LogMsg "-" "${CUR_OUTPUT}"
            LogMsg "-"

            LogMsg "Resetting the USB port used for the phone now ..."

            reset_the_usb_port_for_the_phone

            LogMsg "The list of known adb devices is now:"
            CUR_OUTPUT="$( adb devices 2>&1 )"
            LogMsg "-"
            LogMsg "-" "${CUR_OUTPUT}"
            LogMsg "-"
            ;;            
             
          t | T | twrp )
          
            LogMsg "-"
            LogMsg "The current TWRP script is \"${TWRP_IMAGE}\" "          
            LogMsg "-"
            LogMsg "Changing the TWRP image for the next tasks"
            printf "Please enter the name of the TWRP image that should be used (<return> to not change the TWRP image) >> "
            read NEW_TWRP_IMAGE
            if [ "${NEW_TWRP_IMAGE}"x = ""x ] ; then
              echo ""
            else

              if [ ! -r "${NEW_TWRP_IMAGE}" ] ; then
                LogErrorMsg "The file \"${NEW_TWRP_IMAGE}\" does not exist"
              elif [ ! -f "${NEW_TWRP_IMAGE}" ] ; then
                LogErrorMsg "The file \"${NEW_TWRP_IMAGE}\" is not a file:"
                LogMsg "-" "${NEW_TWRP_IMAGE}"
              else
                NEW_IWRP_IMAGE_FILE_TYPE="$( file "${NEW_TWRP_IMAGE}" 2>&1 )"
                if [[ "${NEW_IWRP_IMAGE_FILE_TYPE}" != *Android\ bootimg* ]] ; then
                  LogErrorMsg "The file \"${NEW_TWRP_IMAGE}\" is not a Android boot image file:"
                  LogMsg "-" "${NEW_IWRP_IMAGE_FILE_TYPE}"
                else
                  TWRP_IMAGE="${NEW_TWRP_IMAGE}"

                  TWRP_IMAGE_FOR_NEW_OS="${NEW_TWRP_IMAGE}"
                  LogMsg "The TWRP image to use is now \"${TWRP_IMAGE}\" "
                fi
              fi
            fi
            ;;

          q | Q | quit )
            die 100 "Script aborted by the user"
            ;;
          
          !* )
            CUR_COMMAND="${USER_INPUT#*!}"
            LogMsg "Executing the command \"${CUR_COMMAND}\" ..."
            LogMsg "-"
            eval ${CUR_COMMAND}
            LogMsg "-"
            ;;            

          * )
            LogMsg "Unknown command entered: \"${USER_INPUT}\" "
            ;;
        esac
      fi
    done
  fi
  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_os - install an OS image using the TWRP binary twrp
#
# function: install an OS image using the TWRP binary twrp
#
# usage: task_install_os [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [imagefile] [parameter_for_the_script] [sideload]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_os {
  typeset __FUNCTION="task_install_os"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [reset] [imagefile] [parameter_for_the_script] # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}  

  typeset CUR_TASK_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_os_via_twrp.sh"
    
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_OS_IMAGE_TO_INSTALL=""
  
  typeset CMD_PARAMETER=""

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do

    CUR_TASK_PARAMETER="$1"
    shift
      
    case ${CUR_TASK_PARAMETER} in
    
      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      reset | factory_reset )
        CMD_PARAMETER="${CMD_PARAMETER} factory_reset"
        ;;
        
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_OS_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"           
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    [ "${CUR_OS_IMAGE_TO_INSTALL}"x = ""x ] && CUR_OS_IMAGE_TO_INSTALL="${OS_IMAGE_TO_INSTALL}"
    
    CMD_PARAMETER="${CMD_PARAMETER} ${CUR_OS_IMAGE_TO_INSTALL}"

    LogMsg ""
    LogMsg "*** Installing the Android OS using the image \"${OS_IMAGE_TO_INSTALL}\" using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""

    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
      
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    if [ ! -r "${OS_IMAGE_TO_INSTALL}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${OS_IMAGE_TO_INSTALL}\" does not exist"
      THISRC=${__FALSE}
    else
      execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
      THISRC=$?
    fi

  fi

# ---------------------------------------------------------------------

   if [ ${IGNORE_RC} = ${__TRUE} ]; then
     if [ ${THISRC} != ${__TRUE} ] ; then

       TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
       (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))
     
       LogMsg "Ignoring the return code of the task is requested via task parameter"
       THISRC=${__TRUE}
     fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_twrp
#
# function: install TWRP into the boot partition
#
# usage: task_install_twrp [reboot|reboot=no|reboot=yes] [ignorerc] [slot] [twrp_imagefile] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_twrp {
  typeset __FUNCTION="task_install_twrp"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [twrp_imagefile] [parameter_for_the_script]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}


  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""


  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_twrp.sh"
  
  typeset CUR_TWRP_IMAGE_TO_INSTALL=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
      
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi
    
    CMD_PARAMETER=" ${SLOT_FOR_THIS_TASK} ${CMD_PARAMETER} ${CUR_TWRP_IMAGE_TO_INSTALL}" 

    LogMsg ""
    LogMsg "*** Installing the TWRP image \"${CUR_TWRP_IMAGE_TO_INSTALL}\" using the script ${CUR_SCRIPT} with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""

    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else    
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi
    
    execute_script "${CUR_SCRIPT}"  ${CMD_PARAMETER} 
    THISRC=$?

  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then

    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))


      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_magisk_in_boot_partition_only
#
# function: install Magisk into the boot partition but do not create the directory /data/adb
#
# usage: task_install_magisk_in_boot_partition_only [slot] [reboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_magisk_in_boot_partition_only {
  typeset __FUNCTION="task_install_magisk_in_boot_partition_only"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""


  typeset CUR_MAGISK_APK_FILE=""
  
  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_magisk_via_twrp.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the Magisk apk file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
      
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_MAGISK_APK_FILE="${CUR_MAGISK_APK_FILE:=${MAGISK_APK_FILE}}"
    SLOT_FOR_THIS_TASK="${SLOT_FOR_THIS_TASK:=next}"
   

    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi

    CMD_PARAMETER="${SLOT_FOR_THIS_TASK} copy_apk  delete_adb_dir ${CMD_PARAMETER} magisk_apk_file=${CUR_MAGISK_APK_FILE}"

    LogMsg ""
    LogMsg "*** Installing Magisk using the apk file \"${CUR_MAGISK_APK_FILE}\" into the boot partition using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
     TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
     (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_magisk_in_data_adb_only
#
# function: install the Magisk files and directories in /data/adb only
#
# usage: task_install_magisk_in_data_adb_only [reboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_magisk_in_data_adb_only {
  typeset __FUNCTION="task_install_magisk_in_data_adb_only"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""


  typeset CUR_MAGISK_APK_FILE=""
  
  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_magisk_via_twrp.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the Magisk apk file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
      
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_MAGISK_APK_FILE="${CUR_MAGISK_APK_FILE:=${MAGISK_APK_FILE}}"
   
    CMD_PARAMETER=" adb_only ${CMD_PARAMETER} magisk_apk_file=${CUR_MAGISK_APK_FILE}"

    LogMsg ""
    LogMsg "*** Installing the Magisk directories and files in /data/adb from the apk file \"${CUR_MAGISK_APK_FILE}\" using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"

    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_magisk_in_boot_partition
#
# function: install Magisk into the boot partition and create the directory /data/adb
#
# usage: task_install_magisk_in_boot_partition [slot] [reboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_magisk_in_boot_partition {
  typeset __FUNCTION="task_install_magisk_in_boot_partition"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]  # default is: reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_magisk_via_twrp.sh"

  typeset CMD_PARAMETER=""

  typeset CUR_MAGISK_APK_FILE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="yes"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the Magisk apk file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
      
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_MAGISK_APK_FILE="${CUR_MAGISK_APK_FILE:=${MAGISK_APK_FILE}}"
    SLOT_FOR_THIS_TASK="${SLOT_FOR_THIS_TASK:=next}"
    
    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi

    CMD_PARAMETER="${SLOT_FOR_THIS_TASK} copy_apk  ${CMD_PARAMETER} magisk_apk_file=${CUR_MAGISK_APK_FILE}"

    LogMsg ""
    LogMsg "*** Installing Magisk using the apk file \"${CUR_MAGISK_APK_FILE}\" into the boot partition using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""

    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_magisk_v26_in_boot_partition
#
# function: install Magisk v26 or newer into the boot partition and create the directory /data/adb
#
# usage: task_install_magisk_v26_in_boot_partition [slot] [reboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the variable ${MAGISK_v26_APK_FILE} must contain the fully qualified path to the Magisk apk file if the  parameter for the apk file is missing
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_magisk_v26_in_boot_partition {
  typeset __FUNCTION="task_install_magisk_v26_in_boot_partition"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_apkfile] [parameter_for_the_script]  # default is: reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_magisk_via_twrp.sh"

  typeset CMD_PARAMETER=""

  typeset CUR_MAGISK_v26_APK_FILE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="yes"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_v26_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the Magisk apk file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_v26_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
      
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_MAGISK_APK_FILE="${CUR_MAGISK_v26_APK_FILE:=${MAGISK_v26_APK_FILE}}"
    SLOT_FOR_THIS_TASK="${SLOT_FOR_THIS_TASK:=active}"
    
    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi

    if [ "${CUR_MAGISK_v26_APK_FILE}"x = ""x ] ; then
      LogWarningMsg "There is no APK file for Magisk v26 defined"
      CONT=${__FALSE}
    elif [ ! -r "${CUR_MAGISK_v26_APK_FILE}" ] ; then
      LogWarningMsg "The file \"${CUR_MAGISK_v26_APK_FILE}\" does not exist"
      CONT=${__FALSE}
    fi
  fi      

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    CMD_PARAMETER="${SLOT_FOR_THIS_TASK} copy_apk use_apk ${CMD_PARAMETER} magisk_apk_file=${CUR_MAGISK_v26_APK_FILE}"

    LogMsg ""
    LogMsg "*** Installing Magisk using the apk file \"${CUR_MAGISK_v26_APK_FILE}\" into the boot partition using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""

    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi
    
    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
    MAGISK_APK_FILE="${MAGISK_v26_APK_FILE}"

  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_enable_adb
#
# function: enable adb via Magisk after the installation of a new OS
#
# usage: task_enable_adb [reboot|reboot=no|reboot=yes] [ignorerc] [slot] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_adb {
  typeset __FUNCTION="task_enable_adb"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [slot] [parameter_for_the_script]  # default is: no reboot, inactive slot "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}


# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/enable_access_via_adb.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset DO_REBOOT="${REBOOT}"
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
         DO_REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
         DO_REBOOT="no"
        ;;
      
      * )    
        CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
#      LogMsg "WARNING: The task parameter for the slot to use: \"${SLOT_FOR_THIS_TASK}\" is ignored for this task"
#      SLOT_FOR_THIS_TASK=""

       get_slot_for_this_task "${SLOT_FOR_THIS_TASK}"
       SLOT_FOR_THIS_TASK="${BOOT_SLOT}"
    else
#
# default slot for this task is the currently inactive slot
#    
      SLOT_FOR_THIS_TASK=""
    fi

    CMD_PARAMETER="${CMD_PARAMETER} ${SLOT_FOR_THIS_TASK}"
    
    LogMsg ""
    LogMsg "*** Enabling access via adb using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${DO_REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
      
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    retrieve_phone_status

    print_phone_status

#     0 - the phone was successfully booted from the TWRP image
#
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition


    case ${PHONE_STATUS} in
  
      3 ) 
        LogMsg "The phone is currently booted into the Android OS with working adb access -- nothing to do"
       ;;
     
      6 ) 
        LogMsg "The phone is currently booted into the safe-mode of the Android OS with working adb access -- nothing to do"
        ;;

      * )
        export PUBLIC_KEY_ON_PC
        execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
        THISRC=$?
    
        if [ ${THISRC} = 0 ] ; then
          if [ "${DO_REBOOT}"x = "yes"x ] ; then
            LogMsg "-"

            LogMsg "-"
            LogMsg "*** Rebooting the phone now ...."
            reboot_phone wait 
            if [ $? -ne ${__TRUE} ] ; then
              LogErrorMsg "Rebooting the phone failed"
              THISRC=${__FALSE}
            else
#
# try to read the UID for the shell; the global variable SHELL_UID is used in the task task_enable_root_access_for_the_shell
#
              LogMsg "Retrieving the UID from the shell ..."

              wait_until_an_android_service_is_ready "package"

              SHELL_UID=""
              CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell pm list packages -U 2>&1 )"
              if [ $? -eq 0 ] ; then
                SHELL_UID="$( echo "${CUR_OUTPUT}" | grep com.android.shell | cut -f3 -d ":" )"
              fi

#              SHELL_UID="$( ${ADB} ${ADB_OPTIONS} shell pm list packages -U 2>/dev/null | grep com.android.shell | cut -f3 -d ":" )"

              if [ "${SHELL_UID}"x != ""x ] ; then
                LogMsg "The UID for the shell is \"${SHELL_UID}\" "
              else
                LogMsg "-" 
                LogMsg "-" "${CUR_OUTPUT}"
                LogMsg "-" 
                LogMsg "Could not retrieve the UID for the shell (this is not an error; the UID will be retrieved later)"
              fi
            fi
          fi
        fi  
     
    esac
  fi
    
# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ] ; then
    if [ ${THISRC} != ${__TRUE} ] ; then
     TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
     (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_enable_root_access_for_the_shell
#
# function: enable root acess via Magisk for the shell
#
# usage: task_enable_root_access_for_the_shell [reboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# The task uses the global variable SHELL_UID if it is not empty
# The variable SHELL_UID is set in the task task_enable_adb
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_root_access_for_the_shell {
  typeset __FUNCTION="task_enable_root_access_for_the_shell"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [parameter_for_the_script]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/init_magisk_db.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER}"

# ??? for testing
#
    if [ "${SHELL_UID}"x = ""x ] ; then
      LogMsg "Using the default shell ID (2000) ..."
      SHELL_UID=2000
    fi
    
    if [ "${SHELL_UID}"x != ""x ] ; then
      CMD_PARAMETER="${CMD_PARAMETER} apps=${SHELL_UID}"
    fi  

    LogMsg ""
    LogMsg "*** Enabling root access for shell in Magisk using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_enable_root_access_for_apps
#
# function: enable root acess via Magisk for the apps that need root access
#
# usage: task_enable_root_access_for_apps [reboot|reboot=no|reboot=yes] [ignorerc] [app1 ... app#] # default: use the list in the variable APPS_FOR_ROOT_ACCESS
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_root_access_for_apps {
  typeset __FUNCTION="task_enable_root_access_for_apps"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [parameter_for_the_script]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/init_magisk_db.sh"
  
  typeset CUR_APPS_FOR_ROOT_ACCESS=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#ddd
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        [ "${CUR_TASK_PARAMETER}"x = "default"x ] && CUR_TASK_PARAMETER="${DEFAULT_APPS_FOR_ROOT_ACCESS}"

        if [ "${CUR_TASK_PARAMETER}"x = "default"x ] ; then
          CUR_TASK_PARAMETER="${DEFAULT_APPS_FOR_ROOT_ACCESS}"
        fi

        if [ "${CUR_APPS_FOR_ROOT_ACCESS}"x = ""x ] ; then
          CUR_APPS_FOR_ROOT_ACCESS="${CUR_TASK_PARAMETER}"
        else
          CUR_APPS_FOR_ROOT_ACCESS="${CUR_APPS_FOR_ROOT_ACCESS},${CUR_TASK_PARAMETER}"
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_APPS_FOR_ROOT_ACCESS="${CUR_APPS_FOR_ROOT_ACCESS:=${DEFAULT_APPS_FOR_ROOT_ACCESS}}"

    if [ "${CUR_APPS_FOR_ROOT_ACCESS}"x = "none"x ] ; then
      LogMsg "Eabling root access for additional apps is disabled"
      THISRC=${__TRUE}
      CONT=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------
    
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
 
    CMD_PARAMETER="-f apps=+${CUR_APPS_FOR_ROOT_ACCESS}"
       
    LogMsg ""
    LogMsg "*** Enabling root access for additional apps using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_essential_scripts
#
# function: install essential scripts on the phone
#
# usage: task_install_essential_scripts [reboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_scripts_to_install]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_essential_scripts {
  typeset __FUNCTION="task_install_essential_scripts"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_scripts_to_install]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
  typeset CUR_ESSENTIAL_SCRIPTS_DIR=""
  
  typeset CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_ESSENTIAL_SCRIPTS_DIR}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the local directory with the scripts found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_ESSENTIAL_SCRIPTS_DIR="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    CUR_ESSENTIAL_SCRIPTS_DIR="${CUR_ESSENTIAL_SCRIPTS_DIR:=${ESSENTIAL_SCRIPTS_DIR}}"

    CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE="${UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}"
 
    CUR_SCRIPT_DIR_ON_THE_PHONE="${SCRIPT_DIR_ON_THE_PHONE}"

    LogMsg ""
    LogMsg "*** Installing the essential scripts from the local directory \"${CUR_ESSENTIAL_SCRIPTS_DIR}\" onto the phone  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    THISRC=${__FALSE}

    if [ ! -d "${CUR_ESSENTIAL_SCRIPTS_DIR}"  ]  ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The directory with the essential scripts \"${CUR_ESSENTIAL_SCRIPTS_DIR}\" does not exist"
    elif [ ! -r "${CUR_ESSENTIAL_SCRIPTS_DIR}"/* ] ; then
      LogWarningMsg "The directory \"${CUR_ESSENTIAL_SCRIPTS_DIR}\" is empty"
      THISRC=${__TRUE}
      CONT=${__FALSE}
    else
#
# boot the phone into the Android OS if not already done
#
      ${PREFIX_FOR_THE_COMMANDS}  reboot_phone
      if [ $? -eq ${__TRUE} ] ; then
      
# wait until /sdcard is mounted
#
        wait_until_sdcard_is_mounted 120
      
        ${PREFIX_FOR_THE_COMMANDS}  check_root_access ;
        if [ $? -eq ${__TRUE} ] ; then
          wait_until_sdcard_is_mounted 20

          LogMsg "Copying the scripts to the phone ..."

#            ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} push "${CUR_ESSENTIAL_SCRIPTS_DIR}/"* "${CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}/" && \

          CUR_OUTPUT="$( exec 2>&1 ;
            ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} shell mkdir -p "${CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}" && sleep 5 && \
            for CUR_FILE in "${CUR_ESSENTIAL_SCRIPTS_DIR}/"* ; do
              ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} push "${CUR_FILE}" "${CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}/"
            done
            ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} "mkdir -p ${CUR_SCRIPT_DIR_ON_THE_PHONE}" && \
            ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} "cp ${CUR_UPLOAD_DIR_FOR_SCRIPTS_ON_THE_PHONE}/* ${CUR_SCRIPT_DIR_ON_THE_PHONE} " && \
            ${PREFIX_FOR_THE_COMMANDS}  ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} "chmod -R 755 ${CUR_SCRIPT_DIR_ON_THE_PHONE}/*"   )"  && THISRC=${__TRUE}
          LogMsg "-" "${CUR_OUTPUT}"
          if [ ${THISRC} != ${__TRUE} ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: An error occured while coyping the essential scripts from the directory \"${CUR_ESSENTIAL_SCRIPTS_DIR}\" to the phone"
          else
            LogMsg "Successfully copied the essential scripts from the directory \"${CUR_ESSENTIAL_SCRIPTS_DIR}\" to the phone"
          fi
        fi
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_essential_apps
#
# function: install essential apps
#
# usage: task_install_essential_apps [reboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_apk_files_to_install]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_essential_apps {
  typeset __FUNCTION="task_install_essential_apps"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_apk_files_to_install]  # default is: no reboot "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_apk.sh"
  
  typeset CUR_ESSENTIAL_APPS_DIR=""
 
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset APKS_INSTALLED=""
  typeset NO_OF_APKS_INSTALLED=0
  
  typeset APKS_NOT_INSTALLED=""
  typeset NO_OF_APKS_NOT_INSTALLED=0

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_ESSENTIAL_APPS_DIR}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the local directory with the scripts found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_ESSENTIAL_APPS_DIR="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    CUR_ESSENTIAL_APPS_DIR="${CUR_ESSENTIAL_APPS_DIR:=${ESSENTIAL_APPS_DIR}}"
  
    LogMsg ""
    LogMsg "*** Installing the essential apps from the local directory \"${CUR_ESSENTIAL_APPS_DIR}\" onto the phone using the script \"${CUR_SCRIPT}\" ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    THISRC=${__FALSE}

    if [ ! -d "${CUR_ESSENTIAL_APPS_DIR}"  ]  ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The directory with the essential apps \"${CUR_ESSENTIAL_APPS_DIR}\" does not exist"
    elif [ ! -x "${CUR_SCRIPT}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The script \"${CUR_SCRIPT}\" does not exist or is not executable"     
    else
#
# boot the phone into the Android OS if not already done
#      
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone
      if [ $? -eq ${__TRUE} ] ; then

# wait until /sdcard is mounted
#
        wait_until_sdcard_is_mounted 120
        
        THISRC=${__TRUE}

# 18.12.2023 /bs
#
# allow installation onf apps for not supported SDK versions
# -> avoid the error message
# Failure [INSTALL_FAILED_DEPRECATED_SDK_VERSION: App package must target at least SDK version 23, but found 19]


# 23.12.2023 /bs
# the option  --bypass-low-target-sdk-block is only available in Android 14
#
        if [ "${NO_BYPASS_LOW_TARGET}"x = ""x ] ; then
          CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell getprop ro.build.version.release 2>/dev/null )"
          if [ "${CUR_OUTPUT}"x = "14"x ] ; then 
            LogMsg "Android ${CUR_OUTPUT} found -- using the pm install option \"--bypass-low-target-sdk-block\" "
            LogMsg "(Set the environment variable NO_BYPASS_LOW_TARGET to a non-zero value to suppress using this parameter)"
          
            export PM_INSTALL_OPTIONS="${PM_INSTALL_OPTIONS} --bypass-low-target-sdk-block "
          else
            LogInfo "Android ${CUR_OUTPUT} found -- the pm install option --bypass-low-target-sdk-block is not necessary"
          fi
        else
          LogInfo "Environment variable \"NO_BYPASS_LOW_TARGET\" is not empty -- not using the pm install option \"--bypass-low-target-sdk-block\" "
        fi

# wait until the Android service for installing packages is ready
#
        wait_until_an_android_service_is_ready "package"
        wait_some_seconds 20
        
        for CUR_PKG in "${CUR_ESSENTIAL_APPS_DIR}"/* ; do
           if [[ ${CUR_PKG} == */\* ]] ; then
             LogWarningMsg "No apks found in the directory \"${CUR_ESSENTIAL_APPS_DIR}\" "

             THISRC=${__TRUE}
             CONT=${__FALSE}
             
             break
           fi
#          [[ ${CUR_PKG} == */Magisk*.apk ]] && continue

          executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${CUR_SCRIPT} ${ADB_OPTIONS} --  --install_on_phone ${CUR_PKG} 
          if [ $? -eq 0 ] ; then
            APKS_INSTALLED="${APKS_INSTALLED} ${CUR_PKG}"
            (( NO_OF_APKS_INSTALLED = NO_OF_APKS_INSTALLED + 1 ))
          
          else
            APKS_NOT_INSTALLED="${APKS_NOT_INSTALLED} ${CUR_PKG}"
            (( NO_OF_APKS_NOT_INSTALLED = NO_OF_APKS_NOT_INSTALLED + 1 ))

            THISRC=${__FALSE}
          fi
        done

        LogMsg "-"
        LogMsg "Summary:"
        
        if [ ${NO_OF_APKS_INSTALLED} != 0 ] ; then
          LogMsg "-"
          LogMsg "${NO_OF_APKS_INSTALLED} apk(s) successfully installed:"
          LogMsg "-" "$( echo "${APKS_INSTALLED}" | tr " " "\n" )"
        fi

        if [ ${NO_OF_APKS_NOT_INSTALLED} != 0 ] ; then
          LogMsg "-"
          LogMsg "${NO_OF_APKS_NOT_INSTALLED} apk(s) not installed:"
          LogMsg "-" "$( echo "${APKS_NOT_INSTALLED}" | tr " " "\n" )"
        fi

      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_essential_magisk_modules
#
# function: install essential Magisk modules
#
# usage: task_install_essential_magisk_modules [reboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_magisk_modules_to_install]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_essential_magisk_modules {
  typeset __FUNCTION="task_install_essential_magisk_modules"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [dir_with_the_magisk_modules_to_install]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""
  
  typeset CUR_ESSENTIAL_MAGISK_MODULES_DIR=""

  typeset CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE=""
  
  typeset CUR_MODULE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset MAGISK_MODULES_INSTALLED=""
  typeset NO_OF_MAGISK_MODULES_INSTALLED=0
  
  typeset MAGISK_MODULES_NOT_INSTALLED=""
  typeset NO_OF_MAGISK_MODULES_NOT_INSTALLED=0
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_ESSENTIAL_MAGISK_MODULES_DIR}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the local directory with the scripts found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_ESSENTIAL_MAGISK_MODULES_DIR="${CUR_TASK_PARAMETER}"
          fi
        else    
#           CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
           
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_ESSENTIAL_MAGISK_MODULES_DIR="${CUR_ESSENTIAL_MAGISK_MODULES_DIR:=${ESSENTIAL_MAGISK_MODULES_DIR}}"

    if [ "${CUR_ESSENTIAL_MAGISK_MODULES_DIR}"x  = "none"x ] ; then
      LogMsg "Installing Magisk Modules is disabled"
      THISRC=${__TRUE}
      CONT=${__FALSE}
    fi
  fi
  
# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE="${UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}"
  
    LogMsg ""
    LogMsg "*** Installing the essential Magisk modules from the local directory \"${CUR_ESSENTIAL_MAGISK_MODULES_DIR}\" onto the phone ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    THISRC=${__FALSE}

    if [ ! -d "${CUR_ESSENTIAL_MAGISK_MODULES_DIR}"  ]  ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The directory with the essential Magisk modules \"${CUR_ESSENTIAL_MAGISK_MODULES_DIR}\" does not exist"
#
# boot the phone into the Android OS if not already done
#      
    else
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone
      if [ $? -eq ${__TRUE} ] ; then

# wait until /sdcard is mounted
#
        wait_until_sdcard_is_mounted 120
      
        ${PREFIX_FOR_THE_COMMANDS} check_root_access 
        if [ $? -eq ${__TRUE} ] ; then
          ${PREFIX} ${ADB} ${ADB_OPTIONS} shell mkdir -p "${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}" 
          if [ $? -eq 0 ] ; then
            THISRC=${__TRUE}

            cd ${CUR_ESSENTIAL_MAGISK_MODULES_DIR} && \
              for CUR_MODULE in *.zip ; do
                LogMsg "-"  
                if [[ ${CUR_MODULE} == \*.zip ]] ; then
                  LogWarningMsg "No Magisk Modules found in the directory \"${CUR_ESSENTIAL_MAGISK_MODULES_DIR}\" "

                  THISRC=${__TRUE}
                  CONT=${__FALSE}
                  
                  break
                fi
                LogMsg "*** Installing the Magisk Module ${CUR_MODULE} ..."
                executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} push "${CUR_MODULE}" "${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}/${CUR_MODULE}" && \
                  executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell "${ROOT_ACCESS_PREFIX} magisk --install-module \"'${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}/${CUR_MODULE}'\" " 
                  if [ $? -eq 0 ] ; then

                    MAGISK_MODULES_INSTALLED="${MAGISK_MODULES_INSTALLED} ${CUR_MODULE}"
                    (( NO_OF_MAGISK_MODULES_INSTALLED = NO_OF_MAGISK_MODULES_INSTALLED + 1 ))
                  
                  else
                    MAGISK_MODULES_NOT_INSTALLED="${MAGISK_MODULES_NOT_INSTALLED} ${CUR_MODULE}"
                    (( NO_OF_MAGISK_MODULES_NOT_INSTALLED = NO_OF_MAGISK_MODULES_NOT_INSTALLED + 1 ))

                    THISRC=${__FALSE}
                  fi
              done
            cd -  >/dev/null
          
            LogMsg "-"
            LogMsg "Summary:"
            
            if [ ${NO_OF_MAGISK_MODULES_INSTALLED} != 0 ] ; then
              LogMsg "-"
              LogMsg "${NO_OF_MAGISK_MODULES_INSTALLED} Magisk Module(s) successfully installed:"
              LogMsg "-" "$( echo "${MAGISK_MODULES_INSTALLED}" | tr " " "\n" )"
            fi
    
            if [ ${NO_OF_MAGISK_MODULES_NOT_INSTALLED} != 0 ] ; then
              LogMsg "-"
              LogMsg "${NO_OF_MAGISK_MODULES_NOT_INSTALLED} Magisk Module(s) not installed:"
              LogMsg "-" "$( echo "${MAGISK_MODULES_NOT_INSTALLED}" | tr " " "\n" )"
            fi
    
          else
            THISRC=${__FALSE}
          fi
        fi
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_install_apps
#
# function: install apps
#
# usage: task_install_apps [reboot|reboot=no|reboot=yes] [ignorerc] [apkfile1 ... apkfile#]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_apps {
  typeset __FUNCTION="task_install_apps"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [apkfile1 ... apkfile#]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_apk.sh"
  
  typeset CUR_APPS_TO_INSTALL=""
 
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset APKS_INSTALLED=""
  typeset NO_OF_APKS_INSTALLED=0
  
  typeset APKS_NOT_INSTALLED=""
  typeset NO_OF_APKS_NOT_INSTALLED=0

  typeset APKS_NOT_FOUND=""
  typeset NO_OF_APKS_NOT_FOUND=0
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )          
        CUR_APPS_TO_INSTALL="${CUR_APPS_TO_INSTALL} ${CUR_TASK_PARAMETER}"
        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

#    CMD_PARAMETER="${CMD_PARAMETER} "
  
    LogMsg ""
    LogMsg "*** Installing the apps  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi
  
    if [ "${CUR_APPS_TO_INSTALL}"x = ""x  ]  ; then
      LogMsg "No apps found inthe task parameter"      
    elif [ ! -x "${CUR_SCRIPT}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The script \"${CUR_SCRIPT}\" does not exist"
      THISRC=${__FALSE}
    else
#
# boot the phone into the Android OS if not already done
#      
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone
      if [ $? -eq ${__TRUE} ] ; then

# wait until /sdcard is mounted
#
        wait_until_sdcard_is_mounted 120

        THISRC=${__TRUE}

# 23.12.2023 /bs
#
# allow installation onf apps for not supported SDK versions
# -> avoid the error message
# Failure [INSTALL_FAILED_DEPRECATED_SDK_VERSION: App package must target at least SDK version 23, but found 19]
# the option  --bypass-low-target-sdk-block is only available in Android 14
#
        if [ "${NO_BYPASS_LOW_TARGET}"x = ""x ] ; then
          CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell getprop ro.build.version.release 2>/dev/null )"
          if [ "${CUR_OUTPUT}"x = "14"x ] ; then 
            LogMsg "Android ${CUR_OUTPUT} found -- using the pm install option \"--bypass-low-target-sdk-block\" "
            LogMsg "(Set the environment variable NO_BYPASS_LOW_TARGET to a non-zero value to suppress using this parameter)"
          
            export PM_INSTALL_OPTIONS="${PM_INSTALL_OPTIONS} --bypass-low-target-sdk-block "
          else
            LogInfo "Android ${CUR_OUTPUT} found -- the pm install option --bypass-low-target-sdk-block is not necessary"
          fi
        else
          LogInfo "Environment variable \"NO_BYPASS_LOW_TARGET\" is not empty -- not using the pm install option \"--bypass-low-target-sdk-block\" "
        fi

# wait until the Android service for installing packages is ready
#
        wait_until_an_android_service_is_ready "package"

        for CUR_PKG in ${CUR_APPS_TO_INSTALL}; do
          LogMsg "-"

          [[ ${CUR_PKG} != */* ]] && CUR_PKG="${ESSENTIAL_APPS_DIR}/${CUR_PKG}"
          
          LogMsg "*** Installing the apk file \"${CUR_PKG}\" ..."
          if [ ! -r "${CUR_PKG}" ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: apk file \"${CUR_PKG}\" not found"
            
            APKS_NOT_FOUND="${APKS_NOT_FOUND} ${CUR_PKG}"
            (( NO_OF_APKS_NOT_FOUND = NO_OF_APKS_NOT_FOUND + 1 ))

            THISRC=${__FALSE}
          else
            executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${CUR_SCRIPT} ${ADB_OPTIONS} --  ${CUR_PKG}
            if [ $? -eq 0 ] ; then

              APKS_INSTALLED="${APKS_INSTALLED} ${CUR_PKG}"
              (( NO_OF_APKS_INSTALLED = NO_OF_APKS_INSTALLED + 1 ))
            
            else
              APKS_NOT_INSTALLED="${APKS_NOT_INSTALLED} ${CUR_PKG}"
              (( NO_OF_APKS_NOT_INSTALLED = NO_OF_APKS_NOT_INSTALLED + 1 ))

              THISRC=${__FALSE}
            fi
          fi
        done
        
        LogMsg "-"
        LogMsg "Summary:"
        
        if [ ${NO_OF_APKS_INSTALLED} != 0 ] ; then
          LogMsg "-"
          LogMsg "${NO_OF_APKS_INSTALLED} apk(s) successfully installed:"
          LogMsg "-" "$( echo "${APKS_INSTALLED}" | tr " " "\n" )"
        fi

        if [ ${NO_OF_APKS_NOT_INSTALLED} != 0 ] ; then
          LogMsg "-"
          LogMsg "${NO_OF_APKS_NOT_INSTALLED} apk(s) not installed:"
          LogMsg "-" "$( echo "${APKS_NOT_INSTALLED}" | tr " " "\n" )"
        fi

        if [ ${NO_OF_APKS_NOT_FOUND} != 0 ] ; then
          LogMsg "-"
          LogMsg "${NO_OF_APKS_NOT_FOUND} apk(s) not found:"
          LogMsg "-" "$( echo "${APKS_NOT_FOUND}" | tr " " "\n" )"
        fi
              
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_magisk_modules
#
# function: install Magisk Modules
#
# usage: task_install_magisk_modules [reboot|reboot=no|reboot=yes] [ignorerc] [magisk_module1 ... magisk_module#]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_magisk_modules {
  typeset __FUNCTION="task_install_magisk_modules"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_module1 ... magisk_module#]  # default is: no reboot "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""
  
  typeset CUR_MAGISK_MODULES_TO_INSTALL=""
 
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE=""
  
  typeset CUR_MODULE=""
  
  typeset MAGISK_MODULES_INSTALLED=""
  typeset NO_OF_MAGISK_MODULES_INSTALLED=0
  
  typeset MAGISK_MODULES_NOT_INSTALLED=""
  typeset NO_OF_MAGISK_MODULES_NOT_INSTALLED=0

  typeset MAGISK_MODULES_NOT_FOUND=""
  typeset NO_OF_MAGISK_MODULES_NOT_FOUND=0
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )          
        eval CUR_MAGISK_MODULES_TO_INSTALL=\"${CUR_MAGISK_MODULES_TO_INSTALL} ${CUR_TASK_PARAMETER}\"
        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE="${UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}"
  
    LogMsg ""
    LogMsg "*** Installing the Magisk modules  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

# remove leading and trailing white spaces
#  
    CUR_MAGISK_MODULES_TO_INSTALL=${CUR_MAGISK_MODULES_TO_INSTALL}

    if [ "${CUR_MAGISK_MODULES_TO_INSTALL}"x = ""x  ]  ; then
      LogMsg "No Magisk Modules found in the task parameter"      
    else
#
# boot the phone into the Android OS if not already done
#      
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone
      if [ $? -eq ${__TRUE} ] ; then

# wait until /sdcard is mounted
#
        wait_until_sdcard_is_mounted 120
      
        ${PREFIX_FOR_THE_COMMANDS}  check_root_access ;
        if [ $? -eq ${__TRUE} ] ; then
          ${PREFIX} ${ADB} ${ADB_OPTIONS} shell mkdir -p "${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}" 
          if [ $? -eq 0 ] ; then
            THISRC=${__TRUE}

            for CUR_MODULE in ${CUR_MAGISK_MODULES_TO_INSTALL} ; do
              LogMsg ""  

              [[ ${CUR_MODULE} != */* ]] && CUR_MODULE="${ESSENTIAL_MAGISK_MODULES_DIR}/${CUR_MODULE}"

              LogMsg "*** Installing the Magisk Module ${CUR_MODULE} ..."
              if [ ! -r ${CUR_MODULE} ] ; then
                LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${CUR_MODULE}\" does not exist"

                MAGISK_MODULES_NOT_FOUND="${MAGISK_MODULES_NOT_FOUND} ${CUR_MODULE}"
                (( NO_OF_MAGISK_MODULES_NOT_FOUND = NO_OF_MAGISK_MODULES_NOT_FOUND + 1 ))

                THISRC=${__FALSE}
              else
                executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} push ${CUR_MODULE} ${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}/${CUR_MODULE} && \
                  executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell "${ROOT_ACCESS_PREFIX} magisk --install-module ${CUR_UPLOAD_DIR_FOR_MAGISK_MODULES_ON_THE_PHONE}/${CUR_MODULE} " 
                if [ $? -eq 0 ] ; then
                  MAGISK_MODULES_INSTALLED="${MAGISK_MODULES_INSTALLED} ${CUR_MODULE}"
                  (( NO_OF_MAGISK_MODULES_INSTALLED = NO_OF_MAGISK_MODULES_INSTALLED + 1 ))
                  
                else
                  MAGISK_MODULES_NOT_INSTALLED="${MAGISK_MODULES_NOT_INSTALLED} ${CUR_MODULE}"
                  (( NO_OF_MAGISK_MODULES_NOT_INSTALLED = NO_OF_MAGISK_MODULES_NOT_INSTALLED + 1 ))

                  THISRC=${__FALSE}
                fi
              fi
              done
            cd -  >/dev/null

            LogMsg "-"
            LogMsg "Summary:"
            
            if [ ${NO_OF_MAGISK_MODULES_INSTALLED} != 0 ] ; then
              LogMsg "-"
              LogMsg "${NO_OF_MAGISK_MODULES_INSTALLED} Magisk Module(s) successfully installed:"
              LogMsg "-" "$( echo "${MAGISK_MODULES_INSTALLED}" | tr " " "\n" )"
            fi
    
            if [ ${NO_OF_MAGISK_MODULES_NOT_INSTALLED} != 0 ] ; then
              LogMsg "-"
              LogMsg "${NO_OF_MAGISK_MODULES_NOT_INSTALLED} Magisk Module(s) not installed:"
              LogMsg "-" "$( echo "${MAGISK_MODULES_NOT_INSTALLED}" | tr " " "\n" )"
            fi
    
            if [ ${NO_OF_MAGISK_MODULES_NOT_FOUND} != 0 ] ; then
              LogMsg "-"
              LogMsg "${NO_OF_MAGISK_MODULES_NOT_FOUND} Magisk Module(s) not found:"
              LogMsg "-" "$( echo "${MAGISK_MODULES_NOT_FOUND}" | tr " " "\n" )"
            fi
            
          else
            THISRC=${__FALSE}
          fi
        fi
      fi
    fi                        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_the_magisk_app
#
# function: install the Magisk App
#
# usage: task_install_the_magisk_app [reboot|reboot=no|reboot=yes] [ignorerc] 
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_the_magisk_app {
  typeset __FUNCTION="task_install_the_magisk_app"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [magisk_apk_file]  # default is: no reboot"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/install_apk.sh"
  
  typeset CUR_MAGISK_APK_FILE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_MAGISK_APK_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the Magisk apk file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_MAGISK_APK_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_MAGISK_APK_FILE="${CUR_MAGISK_APK_FILE:=${MAGISK_APK_FILE}}"
    
    CMD_PARAMETER="${CMD_PARAMETER} ${CUR_MAGISK_APK_FILE}"
    
    LogMsg ""
    LogMsg "*** Installing the Magisk App from the apk file \"${CUR_MAGISK_APK_FILE}\" using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    ${PREFIX_FOR_THE_COMMANDS} reboot_phone
    THISRC=$?

#
# wait some seconds
#
    wait_until_sdcard_is_mounted 20

# wait until the Android service for installing packages is ready
#
    if [ ${THISRC} -eq ${__TRUE} ] ; then
      wait_until_an_android_service_is_ready "package"

# ??? workaround for unknown issue!
#
# ???      wait_some_seconds 60
      
      if [ ${THISRC} -eq ${__TRUE} ] ; then
        execute_script "${CUR_SCRIPT}" ${ADB_OPTIONS} -- ${CMD_PARAMETER} 
        if [ $? -eq ${__TRUE} ] ; then
          LogMsg "Magisk app successfully installed"
   
          adb ${ADB_OPTIONS} shell dumpsys package com.topjohnwu.magisk | grep android.permission.POST_NOTIFICATIONS:   >/dev/null
          if [ $? -eq 0 ] ; then
            LogMsg "Granting the permission \"android.permission.POST_NOTIFICATIONS\" for the Magisk app ..."
            CUR_OUTPUT="$( ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell pm grant com.topjohnwu.magisk  android.permission.POST_NOTIFICATIONS 2>&1 )"
            TEMPRC=$?
            LogMsg "-" "${CUR_OUTPUT}"
            if [ ${TEMPRC} -ne 0 ] ; then
              LogWarningMsg "Error granting the permission \"android.permission.POST_NOTIFICATIONS\" for the Magisk app"
            fi
            
            echo "The status of the permission \"android.permission.POST_NOTIFICATIONS\" for the Magisk App is now:"
            adb ${ADB_OPTIONS} shell dumpsys package com.topjohnwu.magisk | grep android.permission.POST_NOTIFICATIONS:     
          else
            echo "The current running Android version does not know the permission \"permission android.permission.POST_NOTIFICATIONS\" "
          fi
        else        
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error installing the Magisk app"
          THISRC=${__FALSE}
        fi
      fi  
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_boot_phone_into_bootloader
#
# function: boot the phone into the bootloader
#
# usage: task_boot_phone_into_bootloader [ignorerc] [force]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_into_bootloader {
  typeset __FUNCTION="task_boot_phone_into_bootloader"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [force]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}
  typeset REBOOT_PARAMETER=""

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
        
      force )
        REBOOT_PARAMETER="force"
        ;;
      
      * )    
           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    
    LogMsg ""
    LogMsg "*** Booting the attached phone into the bootloader  ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status 
    if [ $? -ge 10 ] ;then
      THISRC=${__FALSE}
    else
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone bootloader ${REBOOT_PARAMETER}
      THISRC=$?    
    fi  
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_boot_phone_into_android
#
# function: boot the phone into the Android OS
#
# usage: task_boot_phone_into_android [ignorerc] [force]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_into_android {
  typeset __FUNCTION="task_boot_phone_into_android"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [force] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset REBOOT_PARAMETER=""

  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      nodecrypt | force )
        [[ " ${REBOOT_PARAMETER} " != *\ ${CUR_TASK_PARAMETER}\ * ]] && REBOOT_PARAMETER="${REBOOT_PARAMETER} ${CUR_TASK_PARAMETER}"
        ;;
        
      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
     
      * )           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
    esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Booting the attached phone into the Android OS ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status 
    if [ $? -ge 10 ] ;then
      THISRC=${__FALSE}
    else
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone ${REBOOT_PARAMETER}
      THISRC=$?    
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_boot_phone_into_fastboot
#
# function: boot the phone into the fastboot
#
# usage: task_boot_phone_into_fastboot [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_into_fastboot {
  typeset __FUNCTION="task_boot_phone_into_fastboot"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [force] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset REBOOT_PARAMETER=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      force )
        REBOOT_PARAMETER="force"
        ;;

      * )           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
    esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    
    LogMsg ""
    LogMsg "*** Booting the attached phone into the fastboot ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status 
    if [ $? -ge 10 ] ;then
      THISRC=${__FALSE}
    else
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone fastboot ${REBOOT_PARAMETER}
      THISRC=$?    
    fi
  fi


# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_boot_phone_into_recovery
#
# function: boot the phone into the recovery
#
# usage: task_boot_phone_into_recovery [ignorerc] [force]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_into_recovery {
  typeset __FUNCTION="task_boot_phone_into_recovery"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [force] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset REBOOT_PARAMETER=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
     
      force )
        REBOOT_PARAMETER="force"
        ;;

      * )           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
    esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Booting the attached phone into the recovery  ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status 
    if [ $? -ge 10 ] ;then
      THISRC=${__FALSE}
    else
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone recovery ${REBOOT_PARAMETER}
      THISRC=$?    
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_boot_phone_from_twrp_image
#
# function: boot the phone from the TWRP image file
#
# usage: task_boot_phone_from_twrp_image [ignorerc] [twrp_image] [force] [reboot]
#
# Parameter:
#
#   force - request a reboot from the TWRP image even if the phone is already booted from the TWRP image
#   reboot - request a reboot from the TWRP image even if the phone is booted from TWRP in the boot or recovery partition
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_from_twrp_image {
  typeset __FUNCTION="task_boot_phone_from_twrp_image"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [twrp_image] [force] [reboot]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TWRP_IMAGE_FILE=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}
  
  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}

  typeset CUR_FORCE_REBOOT_INTO_TWRP_IMAGE=${__FALSE}

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      force )
        CUR_FORCE_REBOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      reboot )
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      * )
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_FILE="${CUR_TASK_PARAMETER}"
          fi
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     
    esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${TWRP_IMAGE_FOR_NEW_OS}"x != ""x ] ; then
      LogMsg "Using the TWRP image for the new installed OS \"${TWRP_IMAGE_FOR_NEW_OS}\" "
      CUR_TWRP_IMAGE_FILE="${TWRP_IMAGE_FOR_NEW_OS}"
      TWRP_IMAGE_FOR_NEW_OS=""
    else
      get_twrp_image_for_the_installed_OS

#
# use the default TWRP image if we can not detect the TWRP to be used for the running OS on the phone
#    
      [ "${TEMP_TWRP_IMAGE_TO_USE}"x = ""x ] && TEMP_TWRP_IMAGE_TO_USE="${TWRP_IMAGE}"
    
      CUR_TWRP_IMAGE_FILE="${CUR_TWRP_IMAGE_FILE:=${TEMP_TWRP_IMAGE_TO_USE}}"
    fi


    LogMsg ""
    LogMsg "*** Booting the attached phone from the TWRP image \"${CUR_TWRP_IMAGE_FILE}\"  ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi 

    retrieve_phone_status 
    if [ $? -ge 10 ] ;then
      THISRC=${__FALSE}
    else
      ( 
      export FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} 
      export FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_REBOOT_INTO_TWRP_IMAGE}
      ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image "${CUR_TWRP_IMAGE_FILE}"  )
      THISRC=$?    
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wait_for_access_via_adb
#
# function: wait until the access via adb to the phone works 
#
# usage: task_wait_for_access_via_adb  [ignorerc] [kill] [[timemout=]timeout_in_seconds] 
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wait_for_access_via_adb {
  typeset __FUNCTION="task_wait_for_access_via_adb"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [kill] [[timeout=]timeout_in_seconds] # default: 30 seconds "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""


  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# timeout in seconds
#
  typeset DEFAULT_TIMEOUT_VALUE=30
  typeset TIMEOUT_VALUE=""
  
  typeset NEW_VAL=""
  
  typeset KILL_DAEMON=${__FALSE}

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      kill )
        KILL_DAEMON=${__TRUE}
        ;;

      timeout=* )
        if [ "${TIMEOUT_VALUE}"x = ""x ] ; then
          NEW_VAL=${CUR_TASK_PARAMETER#*=}
  
          if ! isNumber ${NEW_VAL} ;then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the timeout is not a number: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            TIMEOUT_VALUE="${NEW_VAL}"
          fi
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the timeout to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;

      * )    
        if [ "${TIMEOUT_VALUE}"x = ""x ] ; then

          if  ! isNumber ${CUR_TASK_PARAMETER} ;then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the timeout is not a number: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            TIMEOUT_VALUE="${CUR_TASK_PARAMETER}"
          fi
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the timeout to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    TIMEOUT_VALUE="${TIMEOUT_VALUE:=${DEFAULT_TIMEOUT_VALUE}}"

# if using the ASUS Android OS the adb connection sometimes gets offline for unknown reasons
#
    online_adb_connection
     
# return code of the function retrieve_phone_status is:
#
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastboot
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell
#
#    10 - error retrieving the status of the attached phone (or no phone connected)
#    11 - the phone is attached but without permissions to access via fastboot or adb
#  
     retrieve_phone_status  
     TEMPRC=$?

     LogMsg "PHONE_STATUS is ${PHONE_STATUS}"

     case ${PHONE_STATUS} in
       1 | 2 | 3 | 6 | 7 )
         LogMsg "adb access to the phone is working"
         THISRC=${__TRUE}
         ;;
       
       * )
         if [ ${KILL_DAEMON} = ${__TRUE} ] ; then
           restart_adb_daemon            
         fi
         
         LogMsg ""
         LogMsg "*** Waiting up to ${TIMEOUT_VALUE} second(s) for a working access via adb to the attached phone ..."
         LogMsg ""
        
         wait_for_phone_with_a_working_adb_connection ${TIMEOUT_VALUE}
         TEMPRC=$?

         retrieve_phone_status  
         TEMPRC=$?

         LogMsg "PHONE_STATUS is now ${PHONE_STATUS}"
        
         case ${PHONE_STATUS} in
           1 | 2 | 3 | 6 | 7 )
             LogMsg "adb access to the phone is working now"
             THISRC=${__TRUE}
             ;;
       
           * )
             THISRC=${__FALSE}
         esac
         ;;
     esac
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wait_for_phone_state
#
# function: wait until the phone is booted into a special phone state
#
# usage: task_wait_for_phone_state  [ignorerc] [state=#|state] [timeout=timeout_in_seconds]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wait_for_phone_state {
  typeset __FUNCTION="task_wait_for_phone_state"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [state|state=#] [timeout=timeout_in_seconds] # default: 3 30 ; use 0 for infinite; set TIMEOUT_VALUE to define the timeout value via env variable"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""


  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# timeout in seconds
#
  typeset DEFAULT_TIMEOUT_VALUE=30
  
  if [ "${TIMEOUT_VALUE}"x = ""x ] ; then
    typeset TIMEOUT_VALUE=""
  fi
  
  typeset DEFAULT_NEW_PHONE_STATE=3
  typeset NEW_PHONE_STATE=""
  
  typeset NEW_VAL=""
  typeset i=0  
  
  typeset WAIT_MESSAGE=""
  typeset NEW_MODE_ERROR_MSG=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
                 
      timeout=* )
        if [ "${TIMEOUT_VALUE}"x = ""x ] ; then
          NEW_VAL=${CUR_TASK_PARAMETER#*=}
  
          if ! isNumber ${NEW_VAL} ;then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the timeout is not a number: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            TIMEOUT_VALUE="${NEW_VAL}"
          fi
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the timeout to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;

      state=* | * )
        if [ "${NEW_PHONE_STATE}"x = ""x ] ; then
          NEW_VAL="${CUR_TASK_PARAMETER#*=}"
          NEW_PHONE_STATE="${NEW_VAL}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the new state to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    TIMEOUT_VALUE="${TIMEOUT_VALUE:=${DEFAULT_TIMEOUT_VALUE}}"

    if  ! isNumber "${TIMEOUT_VALUE}" ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The value for the timeout \"${TIMEOUT_VALUE}\" is NOT a number"
      THISRC=${__FALSE}
      CONT=${__FALSE}
    fi
    
    NEW_PHONE_STATE="${NEW_PHONE_STATE:=${DEFAULT_NEW_PHONE_STATE}}"

    case ${NEW_PHONE_STATE} in
      
      1 | twrp )
        NEW_PHONE_STATE=1
        WAIT_MESSAGE="Waiting until the phone is booted from a TWRP image"
        NEW_MODE_ERROR_MSG="The phone is not booted from a TWRP image with working adb connection"
        ;;

      2 | twrp_recover | recovery )
        NEW_PHONE_STATE=2  
        WAIT_MESSAGE="Waiting until the phone is booted from TWRP recovery"
        NEW_MODE_ERROR_MSG="The phone is not booted from the TWRP recovery with working adb connection"
        ;;

      3 | android | os | androidos )
        NEW_PHONE_STATE=3  
        WAIT_MESSAGE="Waiting until the phone is booted from the Android OS"
        NEW_MODE_ERROR_MSG="The phone is not booted from the Android OS with working adb connection"
        ;;

      4 | bootloader )
        NEW_PHONE_STATE=4  
        WAIT_MESSAGE="Waiting until the phone is booted into the bootloader "
        NEW_MODE_ERROR_MSG="The phone is not booted into the bootloader with working fastboot access"
        ;;

      5 | fastboot )
        NEW_PHONE_STATE=5  
        WAIT_MESSAGE="Waiting until the phone is booted into the fastboot"
        NEW_MODE_ERROR_MSG="The phone is not booted into the fastboot with working fastboot access"
        ;;

      6 | safemode )
        NEW_PHONE_STATE=6  
        WAIT_MESSAGE="Waiting until the phone is booted into the Android SafeMode"
        NEW_MODE_ERROR_MSG="The phone is not booted into the Android OS safemode with working adb connection"
        ;;

      7 | lineageos_recovery )
        NEW_PHONE_STATE=7  
        WAIT_MESSAGE="Waiting until the phone is booted from the LineageOS recovery"
        NEW_MODE_ERROR_MSG="The phone is not booted from a LineageOS recovery with working adb connection"
        ;;

      8 | sideload )
        NEW_PHONE_STATE=8
        WAIT_MESSAGE="Waiting until the phone is booted into sideload mode"
        NEW_MODE_ERROR_MSG="The phone is not booted into sideload mode"
        ;;
    
      * )
        LogErrorMsg "Task ${__FUNCTION#task_*}: Invalid new state found in the parameter : ${NEW_PHONE_STATE}"
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
    
    esac
  fi    


# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
#
# return code of the function retrieve_phone_status is:
#
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastboot
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell
#
#    10 - error retrieving the status of the attached phone (or no phone connected)
#    11 - the phone is attached but without permissions to access via fastboot or adb
#  
    typeset i=0
    
    if [ ${TIMEOUT_VALUE} = 0 ] ; then
     LogMsg "Will wait forever"
    else 
      LogMsg "Waiting up to ${TIMEOUT_VALUE} second(s)"
    fi
    
    while true ; do
      LogMsg "${WAIT_MESSAGE} (elapsed time: $i second(s))"

      retrieve_phone_status  
      TEMPRC=$?
      LogMsg "-" "$( print_phone_status )"
      
      if [ ${PHONE_STATUS} = ${NEW_PHONE_STATE} ] ; then
        THISRC=${__TRUE}
        break
      elif [ ${TIMEOUT_VALUE} = 0 ] ; then
        :
      else
        if [ $i -ge ${TIMEOUT_VALUE} ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: ${NEW_MODE_ERROR_MSG} after ${TIMEOUT_VALUE} seconds"
          THISRC=${__FALSE}
          break
        fi
      fi

      (( i = i + 5 ))
      sleep 5

    done    

  fi
  
# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_boot_phone_into_safemode
#
# function: boot the phone into the Android safemode
#
# usage: task_boot_phone_into_safemode  [timeout=timeout_in_seconds] [ignorerc] 
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_boot_phone_into_safemode {
  typeset __FUNCTION="task_boot_phone_into_safemode"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [force] [timeout=timeout_in_seconds] # Default: 30 seconds"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset DEFAULT_TIMEOUT_VALUE="30"

  if [ "${TIMEOUT_VALUE}"x = ""x ] ; then
    typeset TIMEOUT_VALUE=""
  fi  
  typeset NEW_VAL=""

  typeset POST_FS_DATA_DIR="/data/adb/post-fs-data.d"
  typeset ENABLE_SAVE_MODE_SCRIPT="${POST_FS_DATA_DIR}/enable_safe_mode"
  typeset MAGISK64="/data/adb/magisk/magisk64"
 
  typeset FORCE_REBOOT=${__FALSE}
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      force )
        FORCE_REBOOT=${__TRUE}
        ;;

      timeout=* )
        if [ "${TIMEOUT_VALUE}"x = ""x ] ; then
          NEW_VAL=${CUR_TASK_PARAMETER#*=}
  
          if ! isNumber ${NEW_VAL} ;then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the timeout is not a number: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            TIMEOUT_VALUE="${NEW_VAL}"
          fi
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the timeout to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;

      * )    
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

#    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Booting the phone into the Android OS safemode  ..."
    LogMsg ""

    TIMEOUT_VALUE="${TIMEOUT_VALUE:=${DEFAULT_TIMEOUT_VALUE}}"

    if  ! isNumber "${TIMEOUT_VALUE}" ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The value for the timeout \"${TIMEOUT_VALUE}\" is NOT a number"
      THISRC=${__FALSE}
      CONT=${__FALSE}
    else
      LogMsg "Will wait up to ${TIMEOUT_VALUE} second(s) after rebooting the phone"
    fi
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi
  fi
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    retrieve_phone_status
    print_phone_status
    
    if [ ${PHONE_STATUS} = 6 -a ${FORCE_REBOOT} != ${__TRUE} ] ; then 
#
# the phone is already booted into the Android SafeMode
#
      LogMsg "The phone is already booted in the Android SafeMode"
    elif [ ${PHONE_STATUS} = 3 -o ${PHONE_STATUS} = 6 ] ; then 
#
# the phone is booted into the Android OS
#
      check_root_access silent

      LogMsg "Booting the phone into the Android safe mode now ..."

      ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} setprop persist.sys.safemode 1 && \
        ${PREFIX_FOR_THE_COMMANDS} reboot_phone safemode force ${TIMEOUT_VALUE}
      if [ $? -ne ${__TRUE} ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error booting the phone into the Android safemode"
      fi
    elif [[ " 1 2 7 6 " == *\ ${PHONE_STATUS}\ * ]] ; then
#
# the phone is booted into a Recovery with adb shell support
#      
      if ! ${ADB} ${ADB_OPTIONS} shell test -x "${MAGISK64}" ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Magisk binary \"${MAGISK64}\" not found on the phone"
        THISRC=${__FALSE}
      elif ! ${ADB} ${ADB_OPTIONS} shell test -d "${POST_FS_DATA_DIR}" ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The phone is booted into the Recovery but there is no Magisk installed (The directory \"${POST_FS_DATA_DIR}\" does not exist)"
        THISRC=${__FALSE}
      else
        LogMsg "Creating a temporary Magisk Start script to boot the phone into the Android Safemode ..."
        
        echo "${MAGISK64} resetprop -n persist.sys.safemode 1 ; rm ${ENABLE_SAVE_MODE_SCRIPT}" | ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell  tee "${ENABLE_SAVE_MODE_SCRIPT}" >/dev/null && \
          ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell chmod 755 "${ENABLE_SAVE_MODE_SCRIPT}"
        if [ $? -ne 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error creating the temporary Magisk start script \"${ENABLE_SAVE_MODE_SCRIPT}\" on the phone"
          THISRC=${__FALSE}
        else
          LogMsg "Booting the phone into the Android safe mode now ..."
          ${PREFIX_FOR_THE_COMMANDS} reboot_phone safemode force ${TIMEOUT_VALUE}
          if [ $? -ne ${__TRUE} ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Error booting the phone into the Android safemode"
            THISRC=${__FALSE}
          fi
        fi
      fi
    else
      LogErrorMsg "Task ${__FUNCTION#task_*}: The phone must be booted into the Android OS or a recovery with enabled adb to reboot into the Android SafeMode"
      THISRC=${__FALSE}
    fi
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_factory_reset_via_twrp
#
# function: do a factory reset via the executable twrp from the TWRP recovery
#
# usage: task_factory_reset_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_factory_reset_via_twrp {
  typeset __FUNCTION="task_factory_reset_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"


# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Doing a factory reset via the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1

    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then
      
      LogMsg "Doing the factory reset now ..."
      
      ${PREFIX_FOR_THE_COMMANDS} format_data
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error formating the data partition"
        ERRORS_FOUND=${__TRUE}
      fi
      
      ${PREFIX_FOR_THE_COMMANDS} format_metadata
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error formating the metadata partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi

    fi
    
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogWarning "Most probably access via adb does not work anymore after rebooting the phone now! Use the Developer options in the Android settings to enable adb again"

      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wipe_dalvik_and_cache_via_twrp
#
# function: wipe the dalvik and cache via the executable twrp from the TWRP recovery
#
# usage: task_wipe_dalvik_and_cache_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wipe_dalvik_and_cache_via_twrp {
  typeset __FUNCTION="task_wipe_dalvik_and_cache_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Wipe Dalvic and cache using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then
    
      ${PREFIX_FOR_THE_COMMANDS} wipe_cache
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error wiping the cache"
        ERRORS_FOUND=${__TRUE}
      fi

      ${PREFIX_FOR_THE_COMMANDS} wipe_dalvik
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error wiping the dalvik"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wipe_dalvik_via_twrp
#
# function: wipe the dalvik via the executable twrp from the TWRP recovery
#
# usage: task_wipe_dalvik_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wipe_dalvik_via_twrp {
  typeset __FUNCTION="task_wipe_dalvik_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Wipe the dalvic using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} wipe_dalvik
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error wiping the dalvik"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wipe_cache_via_twrp
#
# function: wipe the cache via the executable twrp from the TWRP recovery
#
# usage: task_wipe_cache_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wipe_cache_via_twrp {
  typeset __FUNCTION="task_wipe_cache_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Wipe cache using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} wipe_cache
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error wiping the cache"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_wipe_data_via_twrp
#
# function: wipe the data partition via the executable twrp from the TWRP recovery
#
# usage: task_wipe_data_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wipe_data_via_twrp {
  typeset __FUNCTION="task_wipe_data_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Wipe the data partition cache using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} wipe_data
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error wiping the data partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogWarning "Most probably access via adb does not work anymore after rebooting the phone now! Use the Developer options in the Android settings to enable adb again"
    
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_mount_data_via_twrp
#
# function: mount the data partition via the executable twrp from the TWRP recovery
#
# usage: task_mount_data_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_mount_data_via_twrp {
  typeset __FUNCTION="task_mount_data_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Mount the data partition using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} mount_data
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error mounting the data partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then  
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_umount_data_via_twrp
#
# function: umount the data partition via the executable twrp from the TWRP recovery
#
# usage: task_umount_data_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_umount_data_via_twrp {
  typeset __FUNCTION="task_umount_data_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Umount the data partition using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} umount_data
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error umounting the data partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
    
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_format_data_via_twrp
#
# function: format the data partition via the executable twrp from the TWRP recovery
#
# usage: task_format_data_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_format_data_via_twrp {
  typeset __FUNCTION="task_format_data_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Format data partition using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} format_data
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error formating the data partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogWarning "Most probably access via adb does not work anymore after rebooting the phone now! Use the Developer options in the Android settings to enable adb again"
    
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_format_metadata_via_twrp
#
# function: format the metadata partition via the executable twrp from the TWRP recovery
#
# usage: task_format_metadata_via_twrp [reboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_format_metadata_via_twrp {
  typeset __FUNCTION="task_format_metadata_via_twrp"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [twrp_imagefile] [ignorerc] [force|noforce] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_TWRP_IMAGE_TO_INSTALL=""

  typeset CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
  
  typeset ERRORS_FOUND=${__FALSE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE}
        ;;

      noforce )          
        CUR_FORCE_BOOT_INTO_TWRP_IMAGE=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_TWRP_IMAGE_TO_INSTALL}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    CUR_TWRP_IMAGE_TO_INSTALL="${CUR_TWRP_IMAGE_TO_INSTALL:=${TWRP_IMAGE}}"

    LogMsg ""
    LogMsg "*** Format the metadata partition using the TWRP executable \"twrp\"; the TWRP image file to use is \"${CUR_TWRP_IMAGE_TO_INSTALL}\" "
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi

    if [ ${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} = ${__TRUE} ] ; then
      LogMsg "The phone is rebooted from the TWRP image even if it has already been rebooted from the TWRP image."
    else      
      LogMsg "The phone is NOT rebooted from the TWRP image if it has already been rebooted from the TWRP image."
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    retrieve_phone_status
    print_phone_status

    ( FORCE_REBOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ;  FORCE_BOOT_INTO_TWRP_IMAGE=${CUR_FORCE_BOOT_INTO_TWRP_IMAGE} ; ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image  "${CUR_TWRP_IMAGE_TO_INSTALL}" )
    TEMPRC=$?
 
#    
# simulate successfull boot into the TWRP image in dry-run mode
#
    [ "${PREFIX_FOR_THE_COMMANDS}" != ""x ] && PHONE_STATUS=1
    
    if [ ${TEMPRC} -eq ${__TRUE} -a "${PHONE_STATUS}"x = "1"x ] ; then

      ${PREFIX_FOR_THE_COMMANDS} format_metadata
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogError "Error formating the metadata partition"
        ERRORS_FOUND=${__TRUE}
      fi

      if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      ${PREFIX_FOR_THE_COMMANDS} reboot_phone force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_kill_adb_daemon
#
# function: kill the adb daemon on the PC
#
# usage: task_kill_adb_daemon [reboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_kill_adb_daemon {
  typeset __FUNCTION="task_kill_adb_daemon"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""
  
  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_DEBUG_CODE=":"
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then


    [ ${VERBOSE} = ${__TRUE} ] && CUR_DEBUG_CODE="set -x "
    
    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Killing the running adb daemon  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    kill_adb_daemon
         
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_restart_adb_daemon
#
# function: restart the adb daemon on the PC
#
# usage: task_restart_adb_daemon [reboot|reboot=no|reboot=yes] [nowait] [ignorerc] [root]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_restart_adb_daemon {
  typeset __FUNCTION="task_restart_adb_daemon"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [nowait] [root]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""
  
  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_DEBUG_CODE=":"

  typeset WAIT_FOR_ADB_DAEMON=${__TRUE}
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      nowait )
        WAIT_FOR_ADB_DAEMON=${__FALSE}
        ;;
        
      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      root )
        CMD_PARAMETER="root"
        ;;

      * )
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then


    [ ${VERBOSE} = ${__TRUE} ] && CUR_DEBUG_CODE="set -x "

    LogMsg ""
    LogMsg "*** Restart the running adb daemon  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    restart_adb_daemon ${CMD_PARAMETER}
    if [ $? -eq ${__TRUE} -a ${WAIT_FOR_ADB_DAEMON} = ${__TRUE} ] ; then
      wait_for_the_adb_daemon
    fi

  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_start_adb_daemon
#
# function: task_start_adb_daemon
#
# usage: task_start_adb_daemon [reboot|reboot=no|reboot=yes] [ignorerc] [root]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_start_adb_daemon {
  typeset __FUNCTION="task_start_adb_daemon"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [root]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""
  
  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_DEBUG_CODE=":"
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      root )
        CMD_PARAMETER="root"
        ;;

      * )
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then


    [ ${VERBOSE} = ${__TRUE} ] && CUR_DEBUG_CODE="set -x "

    LogMsg ""
    LogMsg "*** Starting the running adb daemon  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    start_adb_daemon ${CMD_PARAMETER}
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}
# ----------------------------------------------------------------------
# task_download_scripts
#
# function: download the scripts used by the tasks
#
# usage: task_download_scripts [target_dir|default|pwd] [backup|nobackup] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_download_scripts {
  typeset __FUNCTION="task_download_scripts"
  typeset TASK_USAGE="${__FUNCTION} [target_dir|default|pwd] [backup|nobackup]  [ignorerc] # default: download the scripts to the current directory "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset SCRIPT_TARGET_DIR=""
 
  typeset CUR_SCRIPT=""
  typeset LIST_OF_URLS=""
  
  typeset CREATE_SCRIPT_BACKUPS=${__TRUE}
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
     
      backup )
        CREATE_SCRIPT_BACKUPS=${__TRUE}
        ;;

      nobackup )
        CREATE_SCRIPT_BACKUPS=${__FALSE}
        ;;
          
      * )    

        if [[ ${CUR_TASK_PARAMETER} == default ]] ;then
          CUR_TASK_PARAMETER="${SCRIPT_DIR}"
        fi

        if [[ ${CUR_TASK_PARAMETER} == pwd ]] ;then
          CUR_TASK_PARAMETER="${WORKING_DIR}"
        fi
                
        if [[ ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${SCRIPT_TARGET_DIR}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the target dir to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            if [[ ${CUR_TASK_PARAMETER} == /* ]] ;then
              SCRIPT_TARGET_DIR="${CUR_TASK_PARAMETER}"
            else
              SCRIPT_TARGET_DIR="${WORKING_DIR}/${CUR_TASK_PARAMETER}"
            fi
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    SCRIPT_TARGET_DIR="${SCRIPT_TARGET_DIR:=${WORKING_DIR}}"
    
    LogMsg "Downloading the scripts to the directory \"${SCRIPT_TARGET_DIR}\" "
 
    if [ ! -d "${SCRIPT_TARGET_DIR}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The directory \"${SCRIPT_TARGET_DIR}\" does not exist"
      THISRC=${__FALSE}
     else
      if ! ${PREFIX_FOR_THE_COMMANDS} touch "${SCRIPT_TARGET_DIR}.testfile.$$" ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Can not write to the direcory  \"${SCRIPT_TARGET_DIR}\" "
       THISRC=${__FALSE}
      else
        ${PREFIX_FOR_THE_COMMANDS} \rm  "${SCRIPT_TARGET_DIR}.testfile.$$" 2>/dev/null
      fi
    fi

    if [ "${LIST_OF_USED_SCRIPTS}"x = ""x ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: Can not retrieve the list of scripts to download"
      THISRC=${__FALSE}
    fi
    
  fi


  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    for CUR_SCRIPT in ${LIST_OF_USED_SCRIPTS} ; do
      LIST_OF_URLS="${LIST_OF_URLS}
${SCRIPTS_DOWNLOAD_URL}/${CUR_SCRIPT}"
    done     

    LogMsg "The URLs of the scripts to download are:"
    LogMsg "-"
    LogMsg "-" "${LIST_OF_URLS}"      
    LogMsg "-"
    
    if [ "${WGET}"x = ""x -a "${CURL}"x = ""x ] ; then
      LogWarning "Neither wget nor curl found via PATH variable - please download the scripts manually"
    elif [ "${WGET}"x != ""x ] ; then
    
      for CUR_SCRIPT in ${LIST_OF_USED_SCRIPTS} ; do
        
        LogMsg "Downloading the script \"${CUR_SCRIPT}\" to  \"${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}\" ..."

        if [ ${CREATE_SCRIPT_BACKUPS} = ${__TRUE} ] ; then
          BackupFile "${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}" "${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}"
        fi

        if [ "${WGET}"x != ""x ] ; then
          executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${WGET} ${WGET_OPTIONS} "${SCRIPTS_DOWNLOAD_URL}/${CUR_SCRIPT}" -O "${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}" 
          TEMPRC=$?
        else
          executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${CURL} ${CURL_OPTIONS} "${SCRIPTS_DOWNLOAD_URL}/${CUR_SCRIPT}" -o "${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}" && \
          TEMPRC=$?
        fi
        [ ${TEMPRC} = 0 ] && executeCommandAndLog  ${PREFIX_FOR_THE_COMMANDS} chmod 755 "${SCRIPT_TARGET_DIR}/${CUR_SCRIPT}"
      
      done

       executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${WGET} ${WGET_OPTIONS} "${SCRIPTS_DOWNLOAD_URL}/prepare_phone.conf" -O "${SCRIPT_TARGET_DIR}/prepare_phone.conf.example" 

    fi
  fi    


# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_wait_n_seconds 
#
# function: wait # seconds
#
# usage: task_wait_n_seconds [wait_time] [step_count]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_wait_n_seconds {
  typeset __FUNCTION="task_wait_n_seconds"
  typeset TASK_USAGE="${__FUNCTION} [wait_time] [step_count] # default for wait_time is 60 and default for step count is 5"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset DEFAULT_WAIT_TIME_IN_SECONDS="60"
  typeset DEFAULT_STEP_COUNT="5"

  typeset WAIT_TIME_IN_SECONDS=""
  typeset STEP_COUNT=""
  
  typeset TEMPVAR=""
  typeset i=0
  
  END_WAIT=${__FALSE}
  
# ---------------------------------------------------------------------
# check for task parameter
#

  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in      
      * )            
        TEMPVAR=$( convert_to_seconds ${CUR_TASK_PARAMETER} )
        if [ "${TEMPVAR}"x = ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        elif [ "${WAIT_TIME_IN_SECONDS}"x = ""x ] ; then
          WAIT_TIME_IN_SECONDS="${TEMPVAR}"
        elif [ "${STEP_COUNT}"x = ""x ] ; then
          STEP_COUNT="${TEMPVAR}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    [ "${WAIT_TIME_IN_SECONDS}"x = ""x ] && WAIT_TIME_IN_SECONDS="${DEFAULT_WAIT_TIME_IN_SECONDS}"
    [ "${STEP_COUNT}"x = ""x ]           && STEP_COUNT="${DEFAULT_STEP_COUNT}"

    LogMsg "Waiting now for ${WAIT_TIME_IN_SECONDS} second(s) in steps of ${STEP_COUNT} seconds  ..."
    LogMsg "To abourt the wait tiime do: press CTRL-C; enter \"END_WAIT=0<return> exit<return>\" "
    i=0
    while [ $i -lt ${WAIT_TIME_IN_SECONDS} ] ; do
      printf "."
      sleep ${STEP_COUNT}
      (( i = i + STEP_COUNT ))
      if [ "${END_WAIT}"x = "${__TRUE}"x ] ; then
        LogMsg "Waiting aborted by the user"
        break
      fi
    done
    printf "\n"   
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_check_config
#
# function: check if the prerequisites for this script are fullfilled
#
# usage: task_check_config
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_check_config {
  typeset __FUNCTION="task_check_config"
  typeset TASK_USAGE="${__FUNCTION} "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_VAR=""
  typeset CUR_VALUE=""
  typeset ERRORS_FOUND=${__FALSE}
  
  typeset CUR_VAR_TYPE=""
  typeset CUR_DIR=""

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in      
      * )    
       LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
       PRINT_TASK_USAGE=${__TRUE}
       THISRC=${__FALSE}
       CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Checking if the prerequisites for this script are full filled ..."

    for CUR_VAR in ${CONFIG_VARIABLES} ; do
      LogMsg "-"
      CUR_VAR_LOCATION="PC"

      CUR_VAR_TYPE="${CUR_VAR#*:}"
      CUR_VAR="${CUR_VAR%%:*}"
      if [ "${CUR_VAR}"x != "${CUR_VAR_TYPE}"x ] ; then
        CUR_VAR_LOCATION="${CUR_VAR_TYPE#*:}"
        CUR_VAR_TYPE="${CUR_VAR_TYPE%%:*}"
        if [ "${CUR_VAR_LOCATION}"x = "${CUR_VAR_TYPE}"x ] ; then
          CUR_VAR_LOCATION=""  
        else 
          CUR_VAR_LOCATION="$( echo "${CUR_VAR_LOCATION}" | tr "A-Z" "a-z" )"
        fi
      else
        CUR_VAR_TYPE=""
      fi

      LogMsg "Checking the variable \"${CUR_VAR}\" ..."
      
      eval CUR_VALUE="\$${CUR_VAR}"

      if [ "${CUR_VALUE}"x = ""x ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The variable  \"${CUR_VAR}\" is NOT defined"
        ERRORS_FOUND=${__TRUE}
        continue
      fi
      
      LogMsg "The current value of the variable \"${CUR_VAR}\" is \"${CUR_VALUE}\" "

      if [ "${CUR_VAR_TYPE}"x = "dir"x ] ; then
        if [ "${CUR_VAR_LOCATION}"x = "phone"x ] ; then
          LogMsg "  (this is a directory on the phone)"
        elif [ ! -d "${CUR_VALUE}" ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: The directory \"${CUR_VALUE}\" does not exist"
          ERRORS_FOUND=${__TRUE}
          continue
        else
          LogMsg "  ok, the directory \"${CUR_VALUE}\" exists"
        fi
        
      elif [ "${CUR_VAR_TYPE}"x = "file"x ] ; then
        if [ "${CUR_VAR_LOCATION}"x = "phone"x ] ; then
          LogMsg "  (this is a file on the phone)"
        elif [ ! -r "${CUR_VALUE}" ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${CUR_VALUE}\" does not exist"
          ERRORS_FOUND=${__TRUE}
          continue
        else
          LogMsg "  ok, the file \"${CUR_VALUE}\" exists"
        fi
      elif [ "${CUR_VAR_TYPE}"x = "script"x ] ; then
        if [ "${CUR_VAR_LOCATION}"x = "phone"x ] ; then
          LogMsg "  (this is a script on the phone)"
        elif [ ! -r "${CUR_VALUE}" ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${CUR_VALUE}\" does not exist or is not executable"
          ERRORS_FOUND=${__TRUE}
          continue
        else
          LogMsg "  ok, the file \"${CUR_VALUE}\" exists and is executable"
        fi
      elif [ "${CUR_VAR_TYPE}"x = "number"x ] ; then
        if ! isNumber ${CUR_VALUE} ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: The value of the variable \"${CUR_VALUE}\" is not a number"
          ERRORS_FOUND=${__TRUE}
          continue
        else
          LogMsg "  ok, \"${CUR_VALUE}\" is a number"
        fi
      elif [ "${CUR_VAR_TYPE}"x != ""x ] ; then
        LogWarningMsg "The type used for the variable \"${CUR_VAR}\" is unknown: \"${CUR_VAR_TYPE}\" "
      fi

    done         
    
    LogMsg "-"
    LogMsg "Checking if all required scripts for the tasks exist ..."
     
    for CUR_SCRIPT in ${LIST_OF_USED_SCRIPTS} ; do
      LogMsg "-"
      THIS_SCRIPT="${SCRIPT_DIR}/${CUR_SCRIPT}"

      LogMsg "Checking the script \"${THIS_SCRIPT}\" ..."
      if [ ! -r "${THIS_SCRIPT}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The script \"${THIS_SCRIPT}\" does not exist"
        ERRORS_FOUND=${__TRUE}
        continue
      elif [ ! -x "${THIS_SCRIPT}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The script \"${THIS_SCRIPT}\" exists but is not executable"
        ERRORS_FOUND=${__TRUE}
        continue
      else
        LogMsg "  ok, the script \"${THIS_SCRIPT}\" exists"
      fi
    done
    
    LogMsg "-"
    if [ ${ERRORS_FOUND} = ${__TRUE} ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: One or more errors found"
      THISRC=${__FALSE}
    fi   
    
  fi

# ---------------------------------------------------------------------


# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_set_os_image_to_install
#
# function: set the OS image to use install
#
# usage: task_set_os_image_to_install [os_image]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_set_os_image_to_install {
  typeset __FUNCTION="task_set_os_image_to_install"
  typeset TASK_USAGE="${__FUNCTION} [os_image] # there is no default value"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CUR_OS_IMAGE_TO_INSTALL=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      * )    
        if [ "${CUR_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the OS image to install found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        elif [ "${CUR_TASK_PARAMETER}"x = "default"x ] ; then
          CUR_OS_IMAGE_TO_INSTALL="${DEFAULT_OS_IMAGE_TO_INSTALL}"
        else
          CUR_OS_IMAGE_TO_INSTALL="${CUR_TASK_PARAMETER}"
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    LogMsg ""
    LogMsg "*** Define the OS image to install .."
    LogMsg ""
    
    if [ "${CUR_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
      [[ ${CUR_OS_IMAGE_TO_INSTALL} != /* ]] && CUR_OS_IMAGE_TO_INSTALL="${WORKING_DIR}/${CUR_OS_IMAGE_TO_INSTALL}"
    
      if [ -d "${CUR_OS_IMAGE_TO_INSTALL}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The OS image found in the parameter \"${CUR_OS_IMAGE_TO_INSTALL}\" is a directory"
        THISRC=${__FALSE}
      elif [ ! -f "${CUR_OS_IMAGE_TO_INSTALL}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The OS image found in the parameter \"${CUR_OS_IMAGE_TO_INSTALL}\" does not exist"
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    while [ "${CUR_OS_IMAGE_TO_INSTALL}"x = ""x ] ; do
      LogMsg "-"

      if [ "${DEFAULT_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
        CUR_PROMPT="*** Please enter the name of the OS image to install (quit to abort, <return> for ${DEFAULT_OS_IMAGE_TO_INSTALL}): "
      else
        CUR_PROMPT="*** Please enter the name of the OS image to install (quit to abort): "
      fi
      AskUser "${CUR_PROMPT} "

      case ${USER_INPUT} in
        q | quit )
          LogMsg "Script aborted by the user"
          THISRC=${__FALSE}
          ABORT_TASK_EXECUTION_ON_ERROR=${__TRUE}
          ;;

        "" )
          if [ "${DEFAULT_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
            CUR_OS_IMAGE_TO_INSTALL="${DEFAULT_OS_IMAGE_TO_INSTALL}"
            break
          fi
          ;;

        * ) 
          [[ ${USER_INPUT} != /* ]] && USER_INPUT="${WORKING_DIR}/${USER_INPUT}"
          if [  -d "${USER_INPUT}" ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: \"${USER_INPUT}\" is a directory"
          elif [ ! -f "${USER_INPUT}" ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${USER_INPUT}\" does not exist"
          else
            CUR_OS_IMAGE_TO_INSTALL="${USER_INPUT}"
            break
          fi
          ;;
      esac
          
    done    
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${CUR_OS_IMAGE_TO_INSTALL}"x != ""x ] ; then
      LogMsg "The OS image to install is \"${CUR_OS_IMAGE_TO_INSTALL}\" "
      LogMsg "Checking the contents of the file ..."
      CUR_OS_IMAGE_TO_INSTALL="$( readlink -f "${CUR_OS_IMAGE_TO_INSTALL}" )"

      CUR_OUTPUT="$( file "${CUR_OS_IMAGE_TO_INSTALL}" | cut -f2- -d":" )"
      if [[ "${CUR_OUTPUT}" != *Java\ archive\ data\ * ]] ; then
        LogWarningMsg "The file \"${CUR_OS_IMAGE_TO_INSTALL}\" seems not to be a valid OS image; the file type is \"${CUR_OUTPUT}\" "
      fi
      CUR_OUTPUT="$( unzip "${CUR_OS_IMAGE_TO_INSTALL}" | grep "payload.bin" 2>&1 )"
      if [ $? -ne 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Task ${__FUNCTION#task_*}: Did not find the mandatory file \"payload.bin\" in the OS image file \"${CUR_OS_IMAGE_TO_INSTALL}\" "      
        THISRC=${__FALSE}
      else
#
# store the new value for the OS image to install in the global variable OS_IMAGE_TO_INSTALL      
#
        OS_IMAGE_TO_INSTALL="${CUR_OS_IMAGE_TO_INSTALL}"
        LogMsg " ... this seems to be a valid OS image"
      fi
    fi
  fi

# ---------------------------------------------------------------------


# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_restore_titanium_backup
#
# function: restore the directory with the titanium backups
#
# usage: task_restore_titanium_backup [license=license_file] [zip=zipfile] [app=titanium_app] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_restore_titanium_backup {
  typeset __FUNCTION="task_restore_titanium_backup"
  typeset TASK_USAGE="${__FUNCTION} [license=license_file] [zip=zipfile] [app=titanium_app] [ignorerc] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# variables for parameter handling
#
  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""
  
  typeset CUR_TITANIUM_UPDATE_ZIP_FILE=""
  
  typeset CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE=""
  
  typeset CUR_TITANIUM_APP=""

  typeset UNZIP_OUTPUT="/tmp/unzip.$$.stdout"
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    shift

    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      license=* | licensefile=* )
        if [ "${CUR_TITANIUM_LICENSE_FILE}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the \"license=\" to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_TITANIUM_LICENSE_FILE="${PARAMETER_VAL}"
        fi
        ;;

      zip=* | zipfile=* )    
        if [ "${CUR_TITANIUM_UPDATE_ZIP_FILE}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the \"zip=\" to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_TITANIUM_UPDATE_ZIP_FILE="${PARAMETER_VAL}"
        fi
        ;;

      app=* )    
        if [ "${CUR_TITANIUM_APP}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the \"app=\" to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_TITANIUM_APP="${PARAMETER_VAL}"
        fi
        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

# 
# use the default values if necessary
#
    CUR_TITANIUM_LICENSE_FILE="${CUR_TITANIUM_LICENSE_FILE:=${TITANIUM_LICENSE_FILE}}"
    CUR_TITANIUM_UPDATE_ZIP_FILE="${CUR_TITANIUM_UPDATE_ZIP_FILE:=${TITANIUM_UPDATE_ZIP_FILE}}"
    CUR_TITANIUM_APP="${CUR_TITANIUM_APP:=${TITANIUM_APP}}"
    CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE="${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE:=${TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}}"

    CUR_ZIP_FILE_NAME="${CUR_TITANIUM_UPDATE_ZIP_FILE##*/}"
    if [ "${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}"x = ""x ] ; then
      CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/${CUR_ZIP_FILE_NAME}"
    elif  [[ ${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE} == */ ]] ; then
      CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE="${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}${CUR_ZIP_FILE_NAME}"    
    fi
    
    LogMsg ""
    LogMsg "*** Restoring the Titanium backups  ..."
    LogMsg ""
 
    if [ "${CUR_TITANIUM_LICENSE_FILE}"x != "none"x ] ; then
      LogMsg "Using the Titanium license file \"${CUR_TITANIUM_LICENSE_FILE}\" "
    else
      LogMsg "Will not install a Titanium license file"
    fi
    
    LogMsg "Using the update zip file \"${CUR_TITANIUM_UPDATE_ZIP_FILE}\" "

    if [ "${CUR_TITANIUM_APP}"x != "none"x ] ; then
      LogMsg "Stopping the Titanium app \"${CUR_TITANIUM_APP}\" after restoring the data"
    else
      LogMsg "Will not stop the Titanium app"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ "${CUR_TITANIUM_LICENSE_FILE}"x != "none"x ] ; then
      if [ ! -r "${CUR_TITANIUM_LICENSE_FILE}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The titanium license file \"${CUR_TITANIUM_LICENSE_FILE}\" does not exist"
        CUR_TITANIUM_LICENSE_FILE=""
      fi
    else
      CUR_TITANIUM_LICENSE_FILE=""    
    fi

    if [ ! -r "${CUR_TITANIUM_UPDATE_ZIP_FILE}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: The update zip file file \"${CUR_TITANIUM_UPDATE_ZIP_FILE}\" does not exist"
      CUR_TITANIUM_UPDATE_ZIP_FILE=""
    fi
          
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
#
#  the task can be done while the phone is booted into the Android OS or in a recovery with adb support
#
    wait_for_phone_with_a_working_adb_connection || ${PREFIX_FOR_THE_COMMANDS} reboot_phone
    if [ $? -ne ${__TRUE} ] ; then
      THISRC=${__FALSE}
      CONT=${__FALSE}
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${CUR_TITANIUM_LICENSE_FILE}"x != ""x ] ; then
      LogMsg "Copying the Titanium license file \"${CUR_TITANIUM_LICENSE_FILE}\" to \"${TITANIUM_LICENSE_FILE_ON_THE_PHONE}\" .."
      executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} push "${CUR_TITANIUM_LICENSE_FILE}" "${TITANIUM_LICENSE_FILE_ON_THE_PHONE}"
      TEMPRC=$?
      if [ ${TEMPRC} -ne 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error copying the Titanium license file \"${CUR_TITANIUM_LICENSE_FILE}\" to \"${TITANIUM_LICENSE_FILE_ON_THE_PHONE}\" "
        THISRC=${__FALSE}
        CONT=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${CUR_TITANIUM_UPDATE_ZIP_FILE}"x != ""x ] ; then
      LogMsg "Copying the Titanium update zip file \"${CUR_TITANIUM_UPDATE_ZIP_FILE}\" to \"${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}\" .."
      executeCommandAndLog ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} push "${CUR_TITANIUM_UPDATE_ZIP_FILE}" "${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}" 
      TEMPRC=$?

      if [ ${TEMPRC} -ne 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error copying the Titanium update zip file \"${CUR_TITANIUM_UPDATE_ZIP_FILE}\" to \"${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}\" "
        THISRC=${__FALSE}
        CONT=${__FALSE}
      else
        LogMsg "Creating the directory \"${TITANIUM_BACKUP_DIR_ON_THE_PHONE}\" on the phone if necessary ..."
        
        CUR_OUTPUT="$( ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell mkdir -p "${TITANIUM_BACKUP_DIR_ON_THE_PHONE}" 2>&1 )"
        TEMPRC=$?
        LogMsg "-" "${CUR_OUTPUT}"
        if [ ${TEMPRC} -ne 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error creating the directory \"${TITANIUM_BACKUP_DIR_ON_THE_PHONE}\" on the phone "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          LogMsg "Unpacking the zip file \"${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}\" into the directory \"${TITANIUM_BACKUP_DIR_ON_THE_PHONE}\" on the phone ..."
          CUR_OUTPUT="$( exec 2>&1;  ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell "cd "${TITANIUM_BACKUP_DIR_ON_THE_PHONE}" && unzip ${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}" >"${UNZIP_OUTPUT}" )"
          TEMPRC=$?
          LogMsg "-" "${CUR_OUTPUT}"
          LogMsg "Note: The STDOUT of the unzip command is in the file \"${UNZIP_OUTPUT}\" "
          if [ ${TEMPRC} -ne 0 ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Error unpacking the zip file \"${CUR_TITANIUM_UPDATE_ZIP_FILE_ON_THE_PHONE}\" into the directory \"${TITANIUM_BACKUP_DIR_ON_THE_PHONE}\" on the phone"
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            if [ "${CUR_TITANIUM_APP}"x != ""x -a "${CUR_TITANIUM_APP}"x != "none"x ] ; then
              if [ ${PHONE_STATUS} = 3 -o ${PHONE_STATUS} = 6 ] ; then
                LogMsg "Stopping a running Titaninum \"${CUR_TITANIUM_APP}\" app now ..."
                CUR_OUTPUT="$( ${PREFIX_FOR_THE_COMMANDS} ${ADB} ${ADB_OPTIONS} shell am force-stop "${CUR_TITANIUM_APP}" 2>&1 )"
                TEMPRC=$?
                LogMsg "-" "${CUR_OUTPUT}"
              else
                LogMsg "The phone is currently not booted into the Android OS - not stopping the Titanium app"
              fi
            fi
          fi      
        fi
      fi
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_execute_script_on_the_phone
#
# function: copy a script to the phone and execute it on the phone
#
# usage: task_execute_script_on_the_phone  [ignorerc] [script_to_execute]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Parameter:
#   script_to_execute
#     - script to copy to the phone and execute it there
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_execute_script_on_the_phone {
  typeset __FUNCTION="task_execute_script_on_the_phone"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [script_to_execute] # default: post_install.sh in the current directory"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset CUR_POST_INSTALL_SCRIPT=""
  typeset CUR_SCRIPT_ON_THE_PHONE=""
  
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}


# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
      
      * )    
        if [ "${CUR_POST_INSTALL_SCRIPT}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the post install script o use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_POST_INSTALL_SCRIPT="${CUR_TASK_PARAMETER}"
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_POST_INSTALL_SCRIPT="${CUR_POST_INSTALL_SCRIPT:=${POST_INSTALL_SCRIPT}}"
    
    [[ ${CUR_POST_INSTALL_SCRIPT} != /* ]] && CUR_POST_INSTALL_SCRIPT="${WORKING_DIR}/${CUR_POST_INSTALL_SCRIPT}"
    
    CUR_SCRIPT_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/${CUR_POST_INSTALL_SCRIPT##*/}"
    
    
    LogMsg ""
    LogMsg "*** Executing the script \"${CUR_POST_INSTALL_SCRIPT}\" on the phone  ..."
    LogMsg ""
     
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    if [ -r "${CUR_POST_INSTALL_SCRIPT}" ] ; then

      LogMsg "Waiting for a working adb connection ..."
      wait_for_phone_with_a_working_adb_connection
      sleep 5
      wait_for_the_adb_daemon
      THISRC=$?
      if [ ${THISRC} = ${__TRUE} ] ; then
        sleep 5
        decrypt_data

        LogMsg "-"
        LogMsg "Copying the script \"${CUR_POST_INSTALL_SCRIPT}\" to \"${CUR_SCRIPT_ON_THE_PHONE}\" on the phone ..."
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} push "${CUR_POST_INSTALL_SCRIPT}" "${CUR_SCRIPT_ON_THE_PHONE}" 2>&1 )"
        TEMPRC=$?
        LogMsg "-" "${CUR_OUTPUT}"
  
        if [ ${TEMPRC} -ne 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error copying the script \"${CUR_POST_INSTALL_SCRIPT}\" to \"${CUR_SCRIPT_ON_THE_PHONE}\" on the phone"
          THISRC=${__FALSE}
        else
          LogMsg "Now executing the script \"${CUR_SCRIPT_ON_THE_PHONE}\" on the phone ..."
          executeCommandAndLog ${ADB} ${ADB_OPTIONS} shell sh "${CUR_SCRIPT_ON_THE_PHONE}"
          TEMPRC=$?
        
          if [ ${TEMPRC} -ne 0 ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Error executing the script \"${CUR_POST_INSTALL_SCRIPT}\" on the phone (RC=${TEMPRC})"
            THISRC=${__FALSE}
          fi
        fi
      else
        LogErrorMsg "Task ${__FUNCTION#task_*}: No working adb connection found"
        THISRC=${__FALSE}
      fi
    else
      LogErrorMsg "Task ${__FUNCTION#task_*}: Script \"${CUR_POST_INSTALL_SCRIPT}\" not found"
      THISRC=${__FALSE}
    fi
    
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_update_include_file
#
# function: download the current version of this include file
#
# usage: task_update_include_file [target_dir|target_file] [ignorerc] [keep|nokeep]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Parameter:
#   keep - do not delete temporary files (only useful for trouble shooting)
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_update_include_file {
  typeset __FUNCTION="task_update_include_file"
  typeset TASK_USAGE="${__FUNCTION} [target_dir|target_file] [ignorerc] [keep|nokeep] # default: nokeep (= delete temporary files)"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE=""


# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset TARGET_PARAMETER=""
  
  typeset TARGET_DIR=""
  typeset TARGET_FILE=""
  
  typeset CURRENT_FILE=""
  
  typeset KEEP_TEMPORARY_FILES=${__FALSE}
  
  typeset COPY_NEW_FILE=${__FALSE}
  
  typeset PRINT_TASK_USAGE=${__FALSE}
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in


      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
      
      keep )
        KEEP_TEMPORARY_FILES=${__TRUE}
        ;;

      nokeep )
        KEEP_TEMPORARY_FILES=${__FALSE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${TARGET_PARAMETER}"x != ""x ]  ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the target directory/file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            TARGET_PARAMETER="${CUR_TASK_PARAMETER}"
          fi
        else            
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi
    
    if [ "${TARGET_PARAMETER}"x != ""x ]  ; then
      if [ -d "${TARGET_PARAMETER}" ] ; then
        TARGET_DIR="${TARGET_PARAMETER}"
      else
        TARGET_FILE="${TARGET_PARAMETER}"
      fi
    fi
    
    [ "${TARGET_DIR}"x = ""x ] && TARGET_DIR="${THIS_INCLUDE_FILE_DIR}"
    [ "${TARGET_FILE}"x = ""x ] && TARGET_FILE="${TARGET_DIR}/${THIS_INCLUDE_FILE_NAME}"
    
    [[ "${TARGET_FILE}" != /* ]] && TARGET_FILE="${WORKING_DIR}/${TARGET_FILE}"
    
    LogMsg ""
    LogMsg "*** Downloading the current version of the include file \"${THIS_INCLUDE_FILE_NAME}\" from the URL \"${INCLUDE_FILE_DOWNLOAD_URL}\" to \"${TARGET_FILE}\"  ..."
    LogMsg ""
    
    if [ "${WGET}"x = ""x -a "${CURL}"x = ""x ] ; then
      LogError "Neither wget nor curl found via PATH variable - please download the include file manually"
      CONT=${__FALSE}
      THISRC=${__FALSE}
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    TMPFILE="/tmp/${THIS_INCLUDE_FILE_NAME}.$$"

    \rm -f "${TMPFILE}"  2>/dev/null
    
    LogInfo "The temporary file used is \"${TMPFILE}\" "

    if [ "${WGET}"x != ""x ] ; then
      LogMsg "Downloading the include file from the URL \"${INCLUDE_FILE_DOWNLOAD_URL}\" using \"${WGET}\" ..."
      executeCommandAndLog  ${WGET} ${WGET_OPTIONS} "${INCLUDE_FILE_DOWNLOAD_URL}" -O "${TMPFILE}" 
      TEMPRC=$?
    else
      LogMsg "Downloading the include file from the ULR \"${INCLUDE_FILE_DOWNLOAD_URL}\" using \"${CURL}\" ..."
      executeCommandAndLog  ${CURL} ${CURL_OPTIONS} "${INCLUDE_FILE_DOWNLOAD_URL}" -o "${TMPFILE}" 
      TEMPRC=$?
    fi
 
    if [ ${TEMPRC} != 0 -o ! -f "${TMPFILE}"  -o ! -s "${TMPFILE}" ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: Error downloading \"${THIS_INCLUDE_FILE_NAME}\" to \"${TMPFILE}\" "
      THISRC=${__FALSE}
    else

      if [ -f "${TARGET_FILE}" ] ; then
        LogMsg "Checking the new file ..."
        CUR_CHECKSUM="$( cksum "${TARGET_FILE}"  | cut -f1 -d " " )"
        NEW_CHECKSUM="$( cksum "${TMPFILE}"  | cut -f1 -d " " )"
        if [ ${CUR_CHECKSUM} -eq ${NEW_CHECKSUM} ] ; then
          LogMsg "The file \"${TARGET_FILE}\" is already the current version"
     
        else
          LogMsg "The file downloaded \"${THIS_INCLUDE_FILE}\" is different to the existing file \"${TARGET_FILE}\" "
          COPY_NEW_FILE=${__TRUE}
        fi
      else
      
#
# target file does not yet exist
#
        COPY_NEW_FILE=${__TRUE}     
      fi
      
      if [ ${COPY_NEW_FILE} = ${__TRUE} ] ; then
        LogMsg "Copying the new file to \"${TARGET_FILE}\" ..."
        BackupFile "${TARGET_FILE}" "${TARGET_FILE}"
        CUR_OUTPUT="$( \cp -f "${TMPFILE}" "${TARGET_FILE}" 2>&1 )"
        TEMPRC=$?
        if [ ${TEMPRC} != 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error copying the file \"${TMPFILE}\" to \"${TARGET_FILE}\" "
          THISRC=${__FALSE}
        else
          LogMsg "File \"${TARGET_FILE}\" successfully updated. "
          if [ "${TARGET_FILE}"x = "${THIS_INCLUDE_FILE}"x ] ; then
            LogMsg "Please restart the script to use the new include file"
          fi
        fi
      fi

      if [ ${KEEP_TEMPORARY_FILES} = ${__TRUE} ] ; then
        LogMsg "The files just downloaded in \"${TMPFILE}\" are not deleted."
      else
        LogInfo "Deleting the temporary file \"${TMPFILE}\" now ..."
        \rm -f "${TMPFILE}"
      fi

    fi

  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_decrypt_data_partition
#
# function: decrypt the data partition
#
# usage: task_decrypt_data_partition [ignorerc] [password]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Parameter:
#
#   password - password to decrypt the phone
#
# If the executable twrp is available via PATH the task uses it. If not the task uses 
# the command "input" to simulate entering the password via GUI keypad (ugly - but at least paritally working)
#
# Notes:
#
# - Without parameter for the password the task uses the password from the environment variable USER_PASSWORD
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_decrypt_data_partition {
  typeset __FUNCTION="task_decrypt_data_partition"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [password]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset CMD_PARAMETER="decrypt"

  typeset CUR_SCRIPT="${SCRIPT_DIR}/boot_phone_from_twrp.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset CUR_USER_PASSWORD=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

#      force )
#        CMD_PARAMETER="${CMD_PARAMETER} force " 
#        ;;
      
      * )
        if [ "${CUR_USER_PASSWORD}"x != ""x ] ; then 
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the password found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_USER_PASSWORD="${CUR_TASK_PARAMETER}"
        fi
        ;;
        
#      * )               
#        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
#        PRINT_TASK_USAGE=${__TRUE}
#        THISRC=${__FALSE}
#        CONT=${__FALSE}
#        ;;

     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi


# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_USER_PASSWORD="${CUR_USER_PASSWORD:=${USER_PASSWORD}}"

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Decyrpting the data partition using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
      
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    ( export USER_PASSWORD="${CUR_USER_PASSWORD}" ; execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} )
    THISRC=$?

  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_install_archive_file
#
# function: unpack a tar file or zip file on the phone
#
# usage: task_install_archive_file [reboot|reboot=no|reboot=yes] [ignorerc] [twrp] [reocvery] [android] [force] [file] [script=scriptname]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Parameter:
#
#   twrp 
#     - boot the phone from the TWRP image before unpacking the tar file
#   recovery 
#     - boot the phone from the recovery before unpacking the tar file
#   android 
#     - boot the phone into the Android OS before unpacking the tar file
#   force 
#    - boot the phone to the boot target even if it's already booted into the boot target
#   file 
#     - tar file or zip file to install on the phone (def.: ${ARCHIVE_FILE})
#       The current working dir when unpacking the file is the root dir "/"
#
#   script=scriptname
#     - execute the script "scriptname" on the phone after unpacking the file if it exists
#       the script will only be executed if unpacking the file was successfull
#       the task will fail if the script ends with an RC not 0
#
#   reboot | reboot=yes
#     - reboot the phone after everything is successfully done
#
#   noreboot | reboot=no
#     - do not reboot the phone after everything is successfully done
#
#   ignorerc
#     - always end the task with the return code ${__TRUE}
#
# Without a boot target parameter the function will not boot the phone; 
# Without a file to install on the phone the task will do nothing and return with ${__TRUE}
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_archive_file {
  typeset __FUNCTION="task_install_archive_file"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [twrp] [reocvery] [android] [force] [file] [script=scriptname]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset BOOT_TARGET=""

  typeset FORCE_REBOOT="${__FALSE}"  
  typeset REBOOT_BEFORE_INSTALLING=${__FALSE}
  
  typeset CUR_ARCHIVE_FILE=""
  typeset CUR_ARCHIVE_FILE_TYPE=""
  
  typeset ARCHIVE_FILE_ON_THE_PHONE=""

  typeset DOWNLOAD_DIR_ON_THE_PHONE=""
  typeset USER_ON_THE_PHONE=""
  typeset CMD_PREFIX=""
  typeset SCRIPT_CONTENTS=""
  typeset UNPACK_SCRIPT_ON_THE_PHONE=""

  typeset POST_INSTALL_SCRIPT=""
  
# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      twrp | recovery | android )
        if [ "${BOOT_TARGET}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the boot target found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          BOOT_TARGET="twrp"
        fi
        ;;

      force )
        FORCE_REBOOT="${__TRUE}"
        ;;
      
      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;

      script=* )
        if [ "${POST_INSTALL_SCRIPT}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the script to execute found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          POST_INSTALL_SCRIPT="${PARAMETER_VAL}"
        fi
        ;;

      * )    
        [[ ${CUR_TASK_PARAMETER} == \$* ]] && eval CUR_TASK_PARAMETER="${CUR_TASK_PARAMETER}"
      
        if [[  ${CUR_TASK_PARAMETER} == */* ]] ;then
          if [ "${CUR_ARCHIVE_FILE}"x != ""x ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the file to use found: \"${CUR_TASK_PARAMETER}\" "
            THISRC=${__FALSE}
            CONT=${__FALSE}
          else
            CUR_ARCHIVE_FILE="${CUR_TASK_PARAMETER}"
          fi
        else    
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi  
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    
    CUR_ARCHIVE_FILE="${CUR_ARCHIVE_FILE:=${ARCHIVE_FILE}}"

    if [ "${CUR_ARCHIVE_FILE}"x = ""x ] ; then
      LogWarningMsg "No file to install found"
      CONT=${__FALSE}
    else
      [[ ${CUR_ARCHIVE_FILE} != /* ]] && CUR_ARCHIVE_FILE="${WORKING_DIR}/${CUR_ARCHIVE_FILE}"
      if [ ! -r "${CUR_ARCHIVE_FILE}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${CUR_ARCHIVE_FILE}\" does not exist"
        TIHSRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CUR_OUTPUT="$( file "${CUR_ARCHIVE_FILE}" |  grep -i "zip archive" 2>/dev/null )"
    if [ $? -eq 0 ] ; then
      CUR_ARCHIVE_FILE_TYPE="zip"
      LogMsg "The file \"${CUR_ARCHIVE_FILE}\" is a zip archive"
      CUR_OUTPUT="$( unzip -t "${CUR_ARCHIVE_FILE}"  2>&1 )"
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Task ${__FUNCTION#task_*}: The zip file seems to be invalid"
        THISRC=${__FALSE}
      fi
    else
      CUR_ARCHIVE_FILE_TYPE="tar"
      LogMsg "Assuming the file \"${CUR_ARCHIVE_FILE}\" is a tar archive"
      CUR_OUTPUT="$( tar -tvf "${CUR_ARCHIVE_FILE}"  2>&1 )"
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Task ${__FUNCTION#task_*}: The tar file seems to be invalid"
        THISRC=${__FALSE}
      fi
    fi
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
        
    LogMsg ""
    LogMsg "*** Installing the contents of the file \"${CUR_ARCHIVE_FILE}\" on the phone  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell

    if [ "${BOOT_TARGET}"x != ""x ]; then
      LogMsg "The requested boot environment to unpack the file is \"${BOOT_TARGET}\" "
    fi
    if [ "${BOOT_TARGET}"x = ""x ]; then
          REBOOT_BEFORE_INSTALLING=${__FALSE}
    elif [ ${BOOT_TARGET} = "twrp" ]; then
      if [[ " 1 " == *\ ${PHONE_STATUS}\ * ]] ; then
        if [ ${FORCE_REBOOT} = ${__TRUE} ]; then
          LogMsg "The phone is already booted from the TWRP image but reboot is requested"
          REBOOT_BEFORE_INSTALLING=${__TRUE}
        fi
      else
        REBOOT_BEFORE_INSTALLING=${__TRUE}      
      fi
    elif [ ${BOOT_TARGET}x = "recovery"x ]; then

      if [[ " 2 " == *\ ${PHONE_STATUS}\ * ]] ; then
        if [ ${FORCE_REBOOT} = ${__TRUE} ]; then
          LogMsg "The phone is already booted from the TWRP image but reboot is requested"
          REBOOT_BEFORE_INSTALLING=${__TRUE}
        fi
      else
        REBOOT_BEFORE_INSTALLING=${__TRUE}      
      fi

    elif [ "${BOOT_TARGET}"x = "android"x ]; then

      if [[ " 3 6 " == *\ ${PHONE_STATUS}\ * ]] ; then
        if [ ${FORCE_REBOOT} = ${__TRUE} ]; then
          LogMsg "The phone is already booted into the Android OS but reboot is requested"
          REBOOT_BEFORE_INSTALLING=${__TRUE}
        fi
      else
        REBOOT_BEFORE_INSTALLING=${__TRUE}      
      fi
    
    fi
    
    if [ ${REBOOT_BEFORE_INSTALLING} = ${__TRUE} ] ; then
      if [ "${BOOT_TARGET}"x = "twrp"x ]; then
        ( 
          export FORCE_BOOT_INTO_TWRP_IMAGE=${__TRUE} 
          export FORCE_REBOOT_INTO_TWRP_IMAGE=${__TRUE}
          ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image "${CUR_TWRP_IMAGE_FILE}"  
          THISRC=$?    
        )
      else
        reboot_phone "${BOOT_TARGET}"
        THISRC=$?
      fi  

      if [ ${THISRC} -ne 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Rebooting the phone failed"
        THISRC=${__FALSE}
      fi

    fi
  fi
  
# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    retrieve_phone_status
    print_phone_status
          
    if [[ " 1 2 3 6 " == *\ ${PHONE_STATUS}\ * ]] ; then
      LogMsg "Retrieving the download directory on the phone ..."
      
      USER_ON_THE_PHONE="$( ${ADB} ${ADB_OPTIONS} shell id -u -n )"
      if [ "${USER_ON_THE_PHONE}"x != "root"x ] ; then
        CMD_PREFIX="su - -c "
        LogMsg "The user on the phone is the user \"${USER_ON_THE_PHONE}\" -- using the command prefix \"${CMD_PREFIX}\" "
      else
        CMD_PREFIX=""
        LogMsg "The user on the phone is the user \"root\" "
      fi      

      DOWNLOAD_DIR_ON_THE_PHONE="/sdcard/Download"
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${CMD_RPEFIX} test -d "${DOWNLOAD_DIR_ON_THE_PHONE}"  2>&1 )"
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        DOWNLOAD_DIR_ON_THE_PHONE="/tmp"
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${CMD_RPEFIX} test -d "${DOWNLOAD_DIR_ON_THE_PHONE}"  2>&1 )"
        if [ ${TEMPRC} != 0 ] ; then
          LogMsg "-" "${CUR_OUTPUT}"
          LogErrorMsg "Task ${__FUNCTION#task_*}: No download directory on the phone found"
          THISRC=${__FALSE}
        fi
      fi
    else
      LogErrorMsg "Task ${__FUNCTION#task_*}: Installing an archive file can not be done in the current mode of the phone"
      THISRC=${__FALSE}   
    fi
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    LogMsg "Now uploading the file \"${CUR_ARCHIVE_FILE}\" to the phone into the directory \"${DOWNLOAD_DIR_ON_THE_PHONE}\" ...." 
    CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} push "${CUR_ARCHIVE_FILE}"  "${DOWNLOAD_DIR_ON_THE_PHONE}" 2>&1 )"
    TEMPRC=$?
    LogMsg "-" "${CUR_OUTPUT}"
    if [ ${TEMPRC} != 0 ] ; then
      LogErrorMsg "Task ${__FUNCTION#task_*}: Error uploading the file \"${CUR_ARCHIVE_FILE}\" to the phone into the directory \"${DOWNLOAD_DIR_ON_THE_PHONE}\" " 
      THISRC=${__FALSE}
    else
      ARCHIVE_FILE_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/${CUR_ARCHIVE_FILE##*/}"
      UNPACK_SCRIPT_ON_THE_PHONE="${DOWNLOAD_DIR_ON_THE_PHONE}/unpack.$$.sh"
    fi
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Creating the temporary script \"${TMPFILE}\" to unpack the file ..."

    if [ "${CUR_ARCHIVE_FILE_TYPE}"x = "zip"x ] ; then
      SCRIPT_CONTENTS="
set -x      
cd / && ${CMD_PREFIX} unzip \"${ARCHIVE_FILE_ON_THE_PHONE}\"
"
    else
      SCRIPT_CONTENTS="
set -x      
cd / &&  ${CMD_PREFIX} tar -omxvf \"${ARCHIVE_FILE_ON_THE_PHONE}\"
"   
    fi
    CUR_OUTPUT="$( ( echo "${SCRIPT_CONTENTS}" >"${TMPFILE}" ) 2>&1 )"
    TEMPRC=$?
    if [ ${TEMPRC} != 0 ] ; then
      LogMsg "-" "${CUR_OUTPUT}"
      LogErrorMsg "Task ${__FUNCTION#task_*}: Error creating the local temporary file \"${TMPFILE}\" "
      THISRC=${__FALSE}
    else
      LogMsg "Uploading the temporary script \"${TMPFILE}\" to the file \"${UNPACK_SCRIPT_ON_THE_PHONE}\" on the phone  ..."
        
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} push "${TMPFILE}" "${UNPACK_SCRIPT_ON_THE_PHONE}" 2>&1 )"
      TEMPRC=$?
      LogMsg "-" "${CUR_OUTPUT}"

      if [ ${TEMPRC} != 0 ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: Error uploading the local temporary file \"${TMPFILE}\" to the file \"${UNPACK_SCRIPT_ON_THE_PHONE}\" on the phone"
        THISRC=${__FALSE}
      else
        LogMsg "Unpacking the file \"${CUR_ARCHIVE_FILE}\" on the phone using the temporary script \"${UNPACK_SCRIPT_ON_THE_PHONE}\" on the phone ...." 
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell sh "${UNPACK_SCRIPT_ON_THE_PHONE}" 2>&1 )"
        TEMPRC=$?
        LogMsg "-" "${CUR_OUTPUT}"
        if [ ${TEMPRC} != 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error executing the script \"${UNPACK_SCRIPT_ON_THE_PHONE}\" on the phone"
          THISRC=${__FALSE}
        else
          LogMsg "Successfully unpacked the file \"${CUR_ARCHIVE_FILE}\" on the phone"
        fi
      fi
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${POST_INSTALL_SCRIPT}"x != ""x ] ; then
      LogMsg "Checking if the post install script \"${POST_INSTALL_SCRIPT}\" exists on the phone ..."
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${CMD_PREFIX} test -r "${POST_INSTALL_SCRIPT}"  2>&1 )"
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"   
        LogWarningMsg "The script \"${POST_INSTALL_SCRIPT}\" does not exist on the phone"
        CONT=${__FALSE}
      else
        LogMsg "Executing the post install script \"${POST_INSTALL_SCRIPT}\" on the phone ..."
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${CMD_PREFIX}  sh "${POST_INSTALL_SCRIPT}" 2>&1 )"
        TEMPRC=$?
        LogMsg "-" "# --------------------------------------------------------------------- "
        LogMsg "-" "${CUR_OUTPUT}"   
        LogMsg "-" "# --------------------------------------------------------------------- "
        LogMsg " ... the RC of the script is ${TEMPRC}"
        if [ ${TEMPRC} != 0 ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Error executing the post install script \"${POST_INSTALL_SCRIPT}\" on the phone (RC=${TEMPRC})"
          THISRC=${__FALSE}
        fi          
      fi
    else
      LogMsg "No post install script defined"
    fi
  fi
  
# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# restart_adbd_on_the_phone
#
# function: restart the adbd on the phone
#
# usage: restart_adbd_on_the_phone
#
# returns: ${__TRUE} - adbd restarted
#
function restart_adbd_on_the_phone {
  typeset __FUNCTION="restart_adbd_on_the_phone"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

  typeset THISRC=${__TRUE}

  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset CUR_ADBD_PROCESS=""
  typeset CUR_ADBD_PID=""
  typeset NEW_ADBD_PROCESS=""
  typeset NEW_ADBD_PID=""

  retrieve_phone_status
  TEMPRC=$?
  if [ ${TEMPRC} -ge 10 ] ; then
    LogErrorMsg "Error retrieving the status of the attached phone (RC=${TEMPRC})"
    THISRC=${__FALSE}
  elif [ "${PHONE_STATUS}"x != "3"x -a "${PHONE_STATUS}"x != "6"x ] ; then
    LogErrorMsg "The phone is NOT booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"
    THISRC=${__FALSE}
  else
    LogInfo "The phone is booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"

    CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"    
    TEMPRC=$?
  
    if [ ${TEMPRC} -ne 0 ]  ; then      
      LogMsg "-" "${CUR_OUTPUT}"

      LogErrorMsg "The adb connection does not work"
      THISRC=${__FALSE}
    elif [ "${CUR_OUTPUT}"x = ""x ] ; then
#      LogMsg "-" "${CUR_OUTPUT}"

      LogErrorMsg "Something went wrong executing \"uname -a\" via adb on the phone"
      THISRC=${__FALSE}
      
    else
      LogInfo "${__FUNCTION}: Output of the adb command :" && \
        LogMsg "-" "${CUR_OUTPUT}"
    
      CUR_ADBD_PROCESS="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ps -ef | grep -v grep | grep adbd  )"
      CUR_ADBD_PID="$( echo "${CUR_ADBD_PROCESS}" | awk '{ print $2}'  )"
      LogInfo "The current adbd process is" && \
        LogMsg "-" "${CUR_ADBD_PROCESS}"

      echo "Restart the adb daemon on the phone now ..."
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell setprop ctl.restart adbd  2>&1 )"    
      TEMPRC=$?
      if [ ${TEMPRC} != 0 -o ${VERBOSE} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
      fi

      wait_some_seconds 5


#     CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"    
#     TEMPRC=$?
    
      NEW_ADBD_PROCESS="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ps -ef |grep -v grep | grep adbd  )"
      NEW_ADBD_PID="$( echo "${NEW_ADBD_PROCESS}" | awk '{ print $2}'  )"
      LogInfo "The current adbd process is now" && \
        LogMsg "-" "${NEW_ADBD_PROCESS}"

      if [ "${NEW_ADBD_PROCESS}"x = ""x ] ; then
        LogErrorMsg "Restarting the adbd failed"
        THISRC=${__FALSE}
      elif [ "${CUR_ADBD_PROCESS}"x != "${NEW_ADBD_PROCESS}"x ] ; then 
        LogMsg "adbd successfully restarted"
      fi
    fi
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_restart_adbd_on_the_phone
#
# function: restart the adb daemon on the phone (adbd)
#
# usage: task_restart_adbd_on_the_phone [reboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_restart_adbd_on_the_phone {
  typeset __FUNCTION="task_restart_adbd_on_the_phone"
  typeset TASK_USAGE="task_restart_adbd_on_the_phone  [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}


# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )              
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Restarting the adbd on the phone ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    restart_adbd_on_the_phone
    THISRC=$?
        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_enable_adb_via_wifi
#
# function: enable adb via wifi
#
# usage: task_enable_adb_via_wifi [port] [restart_adbd|restart_adbd=yes|restart_adbd=no]  [check_port|check_port=yes|check_port=no] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# The default port for the adbd is read from the global variable DEFAULT_ADBD_TCP_PORT
#
# The task stores the port used by the adb for WiFi connections in the global variable
#
# ADBD_TCP_PORT
#
# if successfull.
# The variable is unchanged if the tasks fails.
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_adb_via_wifi {
  typeset __FUNCTION="task_enable_adb_via_wifi"
  
  typeset TASK_USAGE="${__FUNCTION} [port] [restart_adbd|restart_adbd=yes|restart_adbd=no] [check_port|check_port=yes|check_port=no] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc]"
  
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"

  typeset CHECK_IF_ADB_IS_RUNNING=${__FALSE}
  
# restart the adb daemon on the phone after enabling adb via WiFi?
#  
  typeset RESTART_ADBD=${__FALSE}

  typeset CHECK_ADBD_PORT_USED=${__TRUE}
  
  typeset CUR_ADBD_TCP_PORT=""
  
# port used for adbd via WiFi (DEFAULT_ADBD_TCP_PORT is a global variable)
#
  typeset NEW_ADBD_TCP_PORT="${DEFAULT_ADBD_TCP_PORT:=5555}"

# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}


# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      check_port | check_port=yes )
        CHECK_ADBD_PORT_USED=${__TRUE}
        ;;

      check_port=no )
        CHECK_ADBD_PORT_USED=${__FALSE}
        ;;
 
      restart_adbd | restart_adbd=yes )
        RESTART_ADBD=${__TRUE}
        ;;

      restart_adbd=no )
        RESTART_ADBD=${__FALSE}
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if isNumber "${CUR_TASK_PARAMETER}" ; then
          NEW_ADBD_TCP_PORT="${CUR_TASK_PARAMETER}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    retrieve_phone_status
    TEMPRC=$?
    if [ ${TEMPRC} -ge 10 ] ; then
      LogErrorMsg "Error retrieving the status of the attached phone (RC=${TEMPRC})"
      THISRC=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    isNumber "${NEW_ADBD_TCP_PORT}"
    if [ $? -ne ${__TRUE} ] ; then
      LogErrorMsg "The new port for the adbd \"${NEW_ADBD_TCP_PORT}\" is NOT a number"
      THISRC=${__FALSE}
    elif [ ${NEW_ADBD_TCP_PORT} -lt 1024 ] ; then
      LogErrorMsg "The new port for the adbd \"${NEW_ADBD_TCP_PORT}\" is less than 1024"
      THISRC=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Enabling adb via WiFi using the port ${NEW_ADBD_TCP_PORT}  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ "${PHONE_STATUS}"x != "3"x -a "${PHONE_STATUS}"x != "6"x ] ; then
      LogErrorMsg "The phone is NOT booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"
      THISRC=${__FALSE}
    else

      LogInfo "The phone is booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"
      
      CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"    
      TEMPRC=$?
  
      LogInfo "${__FUNCTION}: The output of the command \"uname -a\" executed via \"adb shell\" on the phone is :" && \
        LogMsg "-" "${CUR_OUTPUT}"
  
      if [ ${TEMPRC} -ne 0 ]  ; then      
        LogErrorMsg "The adb connection does not work"
        THISRC=${__FALSE}
      else

        CUR_ADBD_TCP_PORT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell getprop persist.adb.tcp.port  2>/dev/null )"
        if  [ "${CUR_ADBD_TCP_PORT}"x = ""x ] ; then
          LogMsg "adb via WiFi is currently not configured on the phone"
        else
          if [ "${CUR_ADBD_TCP_PORT}"x = "${NEW_ADBD_TCP_PORT}"x ] ; then
            LogMsg "adb via WiFi is currently already configured on the phone to use the port  \"${CUR_ADBD_TCP_PORT}\" "
          else
            LogWarningMsg "adb via WiFi is currently configured on the phone to use the port \"${CUR_ADBD_TCP_PORT}\" "
          fi
          CHECK_IF_ADB_IS_RUNNING=${__TRUE}
        fi
      fi
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    check_root_access silent
    if [ $? = ${__FALSE} ] ; then
      LogErrorMsg "root access is not enabled on the phone - can not change the port used for adb via WiFi"
      THISRC=${__FALSE}
    fi    
  fi  
  
# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${CUR_ADBD_TCP_PORT}"x != "${NEW_ADBD_TCP_PORT}"x ] ; then
      LogMsg "Configuring adb via WiFi to use the port \"${NEW_ADBD_TCP_PORT}\" ..."
      CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} setprop persist.adb.tcp.port ${NEW_ADBD_TCP_PORT} 2>&1 )"
      TEMPRC=$?

      CUR_ADBD_TCP_PORT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} getprop persist.adb.tcp.port  2>/dev/null )"
    
      if [ ${TEMPRC} != 0 -o "${CUR_ADBD_TCP_PORT}"x != "${NEW_ADBD_TCP_PORT}"x ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Something went wrong configuring the port to be used for adb via WiFi"
        THISRC=${__FALSE}
      else

# store the new port for adb in the global variable
#
        ADBD_TCP_PORT="${CUR_ADBD_TCP_PORT}"
      
        LogMsg "The port used for adb via WiFi on the phone is now \"${CUR_ADBD_TCP_PORT}\" "
      
        LogInfo "Output of the command to configure the port to be used for adb via WiFi on the phone:" && \
          LogMsg "-" "${CUR_OUTPUT}"      

        CHECK_IF_ADB_IS_RUNNING=${__TRUE}
      fi        
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${RESTART_ADBD} = ${__TRUE} ] ; then
      LogMsg "Now restarting the adb daemon on the phone ..."
      restart_adbd_on_the_phone
    else
      LogMsg "Restarting the adb daemon on the phone was NOT requested via task parameter \"restart_adbd\" "
    fi        
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CHECK_IF_ADB_IS_RUNNING} = ${__TRUE}  ] ; then

    LogMsg "Checking if the adbd on the phone is listening on the port \"${CUR_ADBD_TCP_PORT}\" ..."

#    CUR_IP_OF_THE_PHONE= "$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ip -br -o addr list  wlan0 | awk '{ print $3}' | cut -f1 -d "/"  )"
  
    CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} netstat -tnlp 2>/dev/null | grep LISTEN  | grep adbd )"
    TEMPRC=$?

    CUR_ADBD_TCP_PORT="$( echo "${CUR_OUTPUT}" | awk '{ print $4}' )"

    CUR_ADBD_TCP_PORT="${CUR_ADBD_TCP_PORT##*:}"
    LogInfo "Output of the netstat command to check if the adbd is listening:" &&
      LogMsg "-" "${CUR_OUTPUT}"

    if [ "${CUR_OUTPUT}"x = ""x ] ; then
      LogWarningMsg "The adb daemon is not listening on any port"
      THISRC=${__FALSE}
    elif [ "${CUR_ADBD_TCP_PORT}"x != "${NEW_ADBD_TCP_PORT}"x ] ; then
      if [ ${CHECK_ADBD_PORT_USED} = ${__TRUE} ] ;then
        LogErrorMsg "The adb daemon is listening on the port \"${CUR_ADBD_TCP_PORT}\" ..."
        THISRC=${__FALSE}
      else
        LogWarningMsg "The adb daemon is listening on the port \"${CUR_ADBD_TCP_PORT}\" ..."
      fi
    else
      LogMsg "The adb daemon is listening on the port \"${CUR_ADBD_TCP_PORT}\" ..."
    fi

    if [ ${THISRC} != ${__TRUE}  ] ; then
      if [ ${RESTART_ADBD} != ${__TRUE} ] ; then
        LogMsg "Restarting the adb daemon was NOT requested via task parameter \"restart_adbd\""
      fi
    fi
    
  fi

# ---------------------------------------------------------------------


  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_disable_adb_via_wifi
#
# function: disable adb via wifi
#
# usage: task_disable_adb_via_wifi [restart_adbd|restart_adbd=yes|restart_adbd=no]  [check_port|check_port=yes|check_port=no] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# The task deletes the variable
#
# ADBD_TCP_PORT
#
# if unconfiguring adb via WiFi was successfull
#
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_disable_adb_via_wifi {
  typeset __FUNCTION="task_disable_adb_via_wifi"
  
  typeset TASK_USAGE="${__FUNCTION} [restart_adbd|restart_adbd=yes|restart_adbd=no] [check_port|check_port=yes|check_port=no] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc]"
  
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"

  typeset CHECK_IF_ADB_IS_RUNNING=${__FALSE}
  
# restart the adb daemon on the phone after enabling adb via WiFi?
#  
  typeset RESTART_ADBD=${__FALSE}

  typeset CHECK_ADBD_PORT_USED=${__TRUE}
  
  typeset CUR_ADBD_TCP_PORT=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}


# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      check_port | check_port=yes )
        CHECK_ADBD_PORT_USED=${__TRUE}
        ;;

      check_port=no )
        CHECK_ADBD_PORT_USED=${__FALSE}
        ;;
 
      restart_adbd | restart_adbd=yes )
        RESTART_ADBD=${__TRUE}
        ;;

      restart_adbd=no )
        RESTART_ADBD=${__FALSE}
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    retrieve_phone_status
    TEMPRC=$?
    if [ ${TEMPRC} -ge 10 ] ; then
      LogErrorMsg "Error retrieving the status of the attached phone (RC=${TEMPRC})"
      THISRC=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Disabling adb via WiFi  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ "${PHONE_STATUS}"x != "3"x -a "${PHONE_STATUS}"x != "6"x ] ; then
      LogErrorMsg "The phone is NOT booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"
      THISRC=${__FALSE}
    else

      LogInfo "The phone is booted into the Android OS (PHONE_STATUS=${PHONE_STATUS})"
      
      CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell uname -a 2>&1 )"    
      TEMPRC=$?
  
      LogInfo "${__FUNCTION}: The output of the command \"uname -a\" executed via \"adb shell\" on the phone is :" && \
        LogMsg "-" "${CUR_OUTPUT}"
  
      if [ ${TEMPRC} -ne 0 ]  ; then      
        LogErrorMsg "The adb connection does not work"
        THISRC=${__FALSE}
      else

        CUR_ADBD_TCP_PORT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell getprop persist.adb.tcp.port  2>/dev/null )"
        if  [ "${CUR_ADBD_TCP_PORT}"x = ""x ] ; then
          LogMsg "adb via WiFi is currently not configured on the phone"
        else
          LogMsg "adb via WiFi is currently configured on the phone to use the port  \"${CUR_ADBD_TCP_PORT}\" "
        fi
        CHECK_IF_ADB_IS_RUNNING=${__TRUE}
      fi
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    check_root_access silent
    if [ $? != ${__TRUE} ] ; then
      LogErrorMsg "root access is NOT enabled on the phone - can not disable adb via WiFi"
      THISRC=${__FALSE}
    fi
  fi  
  
# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Unconfiguring adb via WiFi  ..."
    CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} setprop persist.adb.tcp.port \\\"\\\" 2>&1 )"
    TEMPRC=$?

    CUR_ADBD_TCP_PORT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell getprop persist.adb.tcp.port  2>/dev/null )"
    
    if [ ${TEMPRC} != 0 -o "${CUR_ADBD_TCP_PORT}"x != ""x ] ; then
      LogMsg "-" "${CUR_OUTPUT}"
      LogErrorMsg "Something went wrong unconfiguring the port to be used for adb via WiFi"
      THISRC=${__FALSE}
    else
      LogMsg "The port used for adb via WiFi on the phone is now deleted "
      
      LogInfo "Output of the command to configure the port to be used for adb via WiFi on the phone:" && \
        LogMsg "-" "${CUR_OUTPUT}"      
      CHECK_IF_ADB_IS_RUNNING=${__TRUE}

# delete the global variable for the port
#
      ADBD_TCP_PORT=""

    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${RESTART_ADBD} = ${__TRUE} ] ; then
      LogMsg "Now restarting the adb daemon on the phone ..."
      restart_adbd_on_the_phone
    else
      LogMsg "Restarting the adb daemon on the phone not requested"
    fi        
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CHECK_IF_ADB_IS_RUNNING} = ${__TRUE}  ] ; then

    LogMsg "Checking if the adbd on the phone is still listening ..."

    CUR_OUTPUT="$( timeout 10 ${ADB} ${ADB_OPTIONS} shell ${ROOT_ACCESS_PREFIX} netstat -tnlp 2>/dev/null | grep LISTEN  | grep adbd )"
    TEMPRC=$?

    CUR_ADBD_TCP_PORT="$( echo "${CUR_OUTPUT}" | awk '{ print $4}' )"

    CUR_ADBD_TCP_PORT="${CUR_ADBD_TCP_PORT##*:}"
    LogInfo "Output of the netstat command to check if the adbd is listening:" &&
      LogMsg "-" "${CUR_OUTPUT}"

    if [ "${CUR_OUTPUT}"x = ""x ] ; then
      LogMsg "The adb daemon is not listening on any port anymore"
    else
      LogErrorMsg "The adb daemon is listening on the port \"${CUR_ADBD_TCP_PORT}\" ..."
      THISRC=${__FALSE}
    fi

    if [ ${THISRC} != ${__TRUE}  ] ; then
      if [ ${RESTART_ADBD} != ${__TRUE} ] ; then
        LogMsg "Restarting the adb daemon was NOT requested via task parameter \"restart_adbd\""
      fi
    fi

  fi

# ---------------------------------------------------------------------


  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_connect_using_adb_via_wifi
#
# function: connect to a phone using adb via WiFi
#
# usage: task_connect_using_adb_via_wifi [testonly] [ip=IP] [port=PORT] [localport=PORT] [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# The task stores the parameter necessary to connect to the adb via WiFi in the global variable
#
# ADD_WIFI_OPTIONS
#
# (the variable is empty if the task fails!)
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_connect_using_adb_via_wifi {
  typeset __FUNCTION="task_connect_using_adb_via_wifi"
  typeset TASK_USAGE="${__FUNCTION} [testonly] [ip=IP] [port=PORT] [localport=PORT] [ignorerc] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset ONLY_TEST_THE_CONNECTION=${__FALSE}
  typeset PHONE_IP=""
  typeset ADBD_PORT=""
  typeset LOCAL_PORT=""

# port range for the local ports to use
#
  typeset LOCAL_PORT_START=9000
  typeset LOCAL_PORT_END=9090

  typeset i=0
  
  typeset CUR_ADBD_PPOCESS=""
  typeset CUR_ADBD_PID=""

  typeset CUR_MSG_PART=""
  
# init the used global variable
#
  ADD_WIFI_OPTIONS=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      testonly )
         ONLY_TEST_THE_CONNECTION=${__TRUE}
         ;;

      ip=* )
        PHONE_IP=${PARAMETER_VAL}
        ;;

      port=* )
        ADBD_PORT=${PARAMETER_VAL}
        ;;

      localport=* )
        LOCAL_PORT=${PARAMETER_VAL}
        ;;
      
      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
      
      * )    
           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then


    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Testing the connection to a phone using adb via WiFi  ..."
    LogMsg ""
    
    LogMsg "Checking the task parameter ..."
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ "${PHONE_IP}"x != ""x ] ; then
      if [[ ${PHONE_IP} !=  *.*.*.* ]] ; then
        LogErrorMsg "The IP found in the task parameter is NOT a valid IP address: \"${PHONE_IP}\" "
        THISRC=${__FALSE}
      fi
    fi

    if [ "${ADBD_PORT}"x != ""x ] ; then
      if ! isNumber "${ADBD_PORT}" ; then
        LogErrorMsg "The port for the adbd found in the task parameter is NOT a valid port number: \"${ADBD_PORT}\""
        THISRC=${__FALSE}
        
      fi
    fi

    if [ "${LOCAL_PORT}"x != ""x ] ; then
      if ! isNumber "${LOCAL_PORT}" ; then
        LogErrorMsg "The local port found in the task parameter is NOT a valid port number: \"${LOCAL_PORT}\""
        THISRC=${__FALSE}
      elif [ ${LOCAL_PORT} -lt 1024 -a $( id -u) != 0 ] ; then
        LogMsg "The local port found in the task parameter  \"${LOCAL_PORT}\" is less then 1024 and the current user is not the root user "
        LogMsg "-" "${CUR_OUTPUT}"
        THISRC=${__FALSE}      
      else
        CUR_OUTPUT="$( netstat -tnlp 2>/dev/null | grep LISTEN | grep ":${LOCAL_PORT}[[:space:]]"  2>/dev/null )"
        TEMPRC=$?
        if [ ${TEMPRC} = 0 ] ; then
          LogMsg "The local port found in the task parameter \"${LOCAL_PORT}\" is already in use:"
          LogMsg "-" "${CUR_OUTPUT}"
          THISRC=${__FALSE}
        fi
      fi
    fi       

    if [ ${THISRC} = ${__FALSE} ] ;then
      LogMsg "Task Usage: ${TASK_USAGE}"
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

#
# use default values for missing parameter
#
    if [ "${ADBD_PORT}"x = ""x ] ; then
      if [ "${ADBD_TCP_PORT}"x = ""x ] ; then
        LogErrorMsg "No parameter for the adbd port found in the parameter and there is no value for the port defined (the variable ADBD_TCP_PORT is empty)"
        THISRC=${__FALSE}      
      else
        ADBD_PORT="${ADBD_TCP_PORT}"
      fi
    fi

    if [ "${PHONE_IP}"x = ""x ] ; then
      PHONE_IP="$( timeout 10 ${ADB} shell ip -br -o addr list  wlan0 | awk '{ print $3}' | cut -f1 -d "/"  )"
      if [ "${PHONE_IP}"x = ""x ] ; then
        LogErrorMsg "Can not detect the IP address used on the phone"
        THISRC=${__FALSE}
      fi
    fi
  
    if [ "${LOCAL_PORT}"x = ""x ] ; then
      i=${LOCAL_PORT_START}
      while [ $i -lt ${LOCAL_PORT_END} ] ; do
        LogInfo "Checking if the port \"$i\" is in use ..."
        CUR_OUTPUT="$( netstat -tnl | ${EGREP} ":${i}[[:space:]]"  2>&1 )"
        TEMPRC=$?
        LogInfo "${CUR_OUTPUT}"
        if [ ${TEMPRC} != 0 ] ; then 
          LOCAL_PORT=$i
          break
        fi
        (( i = i + 1 ))
      done
      if [ "${LOCAL_PORT}"x = ""x ] ; then
        LogErrorMsg "No free local port found in the port range ${LOCAL_PORT_START} to ${LOCAL_PORT_END}"
        THISRC=${__FALSE}
      fi        
    fi

    if [ ${THISRC} = ${__FALSE} ] ;then
      LogMsg "Task Usage: ${TASK_USAGE}"
    fi

  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    LogMsg "Connecting using adb via WiFi using the IP ${PHONE_IP}; the tcp port ${ADBD_PORT}, and the local port ${LOCAL_PORT} ..."

# this is a global variable!
#
    ADD_WIFI_OPTIONS="-e -L tcp:localhost:${LOCAL_PORT} "
    
    CUR_OUTPUT="$( timeout 10 ${ADB} ${ADD_WIFI_OPTIONS} connect ${PHONE_IP}:${ADBD_PORT} 2>&1 )"
    TEMPRC=$?
    LogMsg "-" "${CUR_OUTPUT}"


    if [ ${TEMPRC} != 0 ] ; then
      LogErrorMsg "Connecting using adb via WiFi using the IP ${PHONE_IP}; the tcp port ${ADBD_PORT}, and the local port ${LOCAL_PORT} failed (RC=${TEMPRC}"
      THISRC=${__FALSE}
    elif [[ "${CUR_OUTPUT}" == *no\ emulators\ found* ]] ; then
      LogMsg "The connection does not work"
      THISRC=${__FALSE}        
    elif [[ "${CUR_OUTPUT}" == *Connection\ refused* ]] ; then
      LogMsg "The connection does not work"
      THISRC=${__FALSE}
    else
      LogMsg "adb for this connection successfully started"

      CUR_ADBD_PPOCESS="$( ps -ef | grep -v grep |  grep "tcp:localhost:${LOCAL_PORT}" )"
      CUR_ADBD_PID="$( echo "${CUR_ADBD_PPOCESS}" | awk '{print $2}' )"
      LogInfo "The adb process for this connection is " && \
        LogMsg "-" "${CUR_ADBD_PPOCESS}"
      LogInfo "The PID of the started adb is \"${CUR_ADBD_PID}\""

      LogMsg "Now testing the connection ..."
      CUR_OUTPUT="$( timeout 10 ${ADB} ${ADD_WIFI_OPTIONS} ${ADD_WIFI_PARAMETER} shell uname -a 2>&1 )"
      TERMPRC=$?
      LogMsg "-" "${CUR_OUTPUT}"

      if [[ "${CUR_OUTPUT}" == *localhost* ]] ; then
        LogMsg "OK, the connection works"
      else
        LogErrorMsg "The connection does not work"
        THIRC=${__FALSE}
      fi
    fi
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${ONLY_TEST_THE_CONNECTION} = ${__TRUE} ] ; then
      if [ "${CUR_ADBD_PID}"x != ""x ] ; then
        LogMsg "Testing only requested -- now killing the adb for this connection (PID=${CUR_ADBD_PID}) again ..."
        CUR_OUTPUT="$( kill ${CUR_ADBD_PID} 2>&1 )"
        TEMPRC=$?
        LogInfo "Output of the kill command: " && \
          LogMsg "-" "${CUR_OUTPUT}"          
        CUR_MSG_PART=""
      fi
    else
      LogInfo "Killing the adb for this connection not requested"
      CUR_MSG_PART="(Note that the daemon is currently still running)"
    fi   

      LogMsg "-" "#
# To connect to this adb daemon manually use 
#
# start the connection ${CUR_MSG_PART}
#
     ${ADB} ${ADD_WIFI_OPTIONS}  connect ${PHONE_IP}:${ADBD_PORT}
#

#
# open a shell
#
     ${ADB} ${ADD_WIFI_OPTIONS} shell
"

  fi

# ---------------------------------------------------------------------  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_list_taskgroups
#
# function: list all task groups
#
# usage: task_list_taskgroups
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_list_taskgroups {
  typeset __FUNCTION="task_list_taskgroups"
  typeset TASK_USAGE="${__FUNCTION} "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"


  typeset TASK_GROUP_DEFINITIONS=""
  typeset DEFINED_TASK_GROUPS=""
  typeset CUR_TASK_GROUP=""
  typeset TASK_GROUP_DEFINITIONS_WITHOUT_DESC=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  if [ $# -ne 0 ] ; then
    LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
    THISRC=${__FALSE}
    CONT=${__FALSE}
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    TASK_GROUP_DEFINITIONS="$( ${EGREP} "^#T#" "${CUR_INCLUDE_FILE}"| cut -f2- -d" " )"
    DEFINED_TASK_GROUPS="$( ${EGREP} "^TASK_" "${CUR_INCLUDE_FILE}" | cut -f1 -d"=" )"

    for CUR_TASK_GROUP in ${DEFINED_TASK_GROUPS} ; do
      echo "${TASK_GROUP_DEFINITIONS}" | ${EGREP}  "^${CUR_TASK_GROUP}[[:space:]]" >/dev/null ||
        TASK_GROUP_DEFINITIONS_WITHOUT_DESC="${TASK_GROUP_DEFINITIONS_WITHOUT_DESC}    
${CUR_TASK_GROUP}"
    done
    
    i=0
    echo "${TASK_GROUP_DEFINITIONS}"  | awk '{ print $1 }' | while read CUR_TASK_GROUP ; do
      [ $i -lt ${#CUR_TASK_GROUP} ] && i=${#CUR_TASK_GROUP}
    done
    
    LogMsg "-"
    LogMsg "The defined task groups are:"
    LogMsg "-"
    
    echo "${TASK_GROUP_DEFINITIONS}" >"${TMPFILE}"
    while read CUR_TASK_GROUP CUR_TASK_DEFINITION ; do
       printf "%${i}-s %s\n" "${CUR_TASK_GROUP#TASK_GROUP_*}" "${CUR_TASK_DEFINITION}"
    done <"${TMPFILE}"
    
#    LogMsg "-" "${TASK_GROUP_DEFINITIONS}"
    LogMsg "-"
    
    if [ "${TASK_GROUP_DEFINITIONS_WITHOUT_DESC}"x != ""x ] ; then
      LogMsg "The defined task groups without definitions are:"
      LogMsg "-" "${TASK_GROUP_DEFINITIONS_WITHOUT_DESC}"
      LogMsg "-"
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_set_twrp_image_to_use
#
# function: set the TWRP image to use for the tasks
#
# usage: task_set_twrp_image_to_use [force] [twrp_image|default|lineageos]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the task ends with RC=${__FALSE} if the parameter is not a valid Android boot image -- use the parameter "force" to always end the task with RC=${__TRUE}
# - use the parameter "default" to use the default TWRP image
# - use the parameter "lineageos" to use the TWRP image for LineageOS 20 or newer
#
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_set_twrp_image_to_use {
  typeset __FUNCTION="task_set_twrp_image_to_use"
  typeset TASK_USAGE="${__FUNCTION} [force] [twrp_image|default|lineageos] # there is no default value"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CUR_TWRP_IMAGE_TO_USE=""
  
  typeset IGNORE_FILETYPE=${__FALSE}
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      force )
        IGNORE_FILETYPE=${__TRUE}
        ;;

      * )    
        if [ "${CUR_TWRP_IMAGE_TO_USE}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the TWRP image to use found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
          PRINT_TASK_USAGE=${__TRUE}
        elif [ "${CUR_TASK_PARAMETER}"x = "default"x ] ; then
          CUR_TWRP_IMAGE_TO_USE="${TWRP_IMAGE}"
        elif [ "${CUR_TASK_PARAMETER}"x = "lineageos"x ] ; then
          CUR_TWRP_IMAGE_TO_USE="${TWRP_IMAGE_FOR_LINEAGE_OS}"     
        else
          CUR_TWRP_IMAGE_TO_USE="${CUR_TASK_PARAMETER}"
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    LogMsg ""
    LogMsg "*** Define the TWRP image to use ..."
    LogMsg ""
    
    if [ "${CUR_TWRP_IMAGE_TO_USE}"x != ""x ] ; then
      [[ ${CUR_TWRP_IMAGE_TO_USE} != /* ]] && CUR_TWRP_IMAGE_TO_USE="${WORKING_DIR}/${CUR_TWRP_IMAGE_TO_USE}"
    
      if [ -d "${CUR_TWRP_IMAGE_TO_USE}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The TWRP image found in the parameter \"${CUR_TWRP_IMAGE_TO_USE}\" is a directory"
        THISRC=${__FALSE}
      elif [ ! -f "${CUR_TWRP_IMAGE_TO_USE}" ] ; then
        LogErrorMsg "Task ${__FUNCTION#task_*}: The TWRP image found in the parameter \"${CUR_TWRP_IMAGE_TO_USE}\" does not exist"
        THISRC=${__FALSE}
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    while [ "${CUR_TWRP_IMAGE_TO_USE}"x = ""x ] ; do
      LogMsg "-"

      if [ "${TWRP_IMAGE}"x != ""x ] ; then
        CUR_PROMPT="*** Please enter the name of the TWRP image to install (quit to abort, <return> for ${TWRP_IMAGE}): "
      else
        CUR_PROMPT="*** Please enter the name of the TWRP image to use (quit to abort): "
      fi
      AskUser "${CUR_PROMPT} "

      case ${USER_INPUT} in
        q | quit )
          LogMsg "Script aborted by the user"
          THISRC=${__FALSE}
          ABORT_TASK_EXECUTION_ON_ERROR=${__TRUE}
          ;;

        "" )
          if [ "${TWRP_IMAGE}"x != ""x ] ; then
            CUR_TWRP_IMAGE_TO_USE="${TWRP_IMAGE}"
            break
          fi
          ;;

        * ) 
          [[ ${USER_INPUT} != /* ]] && USER_INPUT="${WORKING_DIR}/${USER_INPUT}"
          if [  -d "${USER_INPUT}" ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: \"${USER_INPUT}\" is a directory"
          elif [ ! -f "${USER_INPUT}" ] ; then
            LogErrorMsg "Task ${__FUNCTION#task_*}: The file \"${USER_INPUT}\" does not exist"
          else
            CUR_TWRP_IMAGE_TO_USE="${USER_INPUT}"
            break
          fi
          ;;
      esac
          
    done    
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${CUR_TWRP_IMAGE_TO_USE}"x != ""x ] ; then
      LogMsg "The TWRP image to use is \"${CUR_TWRP_IMAGE_TO_USE}\" "

      LogMsg "Checking the contents of the file ..."
      CUR_TWRP_IMAGE_TO_USE="$( readlink -f "${CUR_TWRP_IMAGE_TO_USE}" )"

      CUR_OUTPUT="$( file "${CUR_TWRP_IMAGE_TO_USE}" | cut -f2- -d":" )"
      CUR_OUTPUT="$( echo ${CUR_OUTPUT} )"
      
      LogMsg "The file type is \"${CUR_OUTPUT}\"  "
      if [[ "${CUR_OUTPUT}"  != *Android\ bootimg* ]] ; then
        if [ ${IGNORE_FILETYPE} = ${__TRUE} ] ; then
          LogWarningMsg "The file \"${CUR_TWRP_IMAGE_TO_USE}\" seems not to be a valid TWRP image"
        else
          LogErrorMsg "The file \"${CUR_TWRP_IMAGE_TO_USE}\" seems not to be a valid TWRP image (use the task parameter \"force\" to use the image anyway)"
          THISRC=${__FALSE}
        fi
      else
        LogMsg "OK; this seems to be a valid Android boot image file"
      fi

      TWRP_IMAGE="${CUR_TWRP_IMAGE_TO_USE}"
    fi
  fi

# ---------------------------------------------------------------------


# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_backup_boot_partition
#
# function: create a backup of a boot partition
#
# usage: task_backup_boot_partition [slot] [reboot|reboot=no|reboot=yes] [ignorerc]  [twrp] [notwrp] [twrp=twrp_image] [[phone=]image_file_on_the_phone] [[pc=]image_file_on_the_pc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the default image file on the phone is "/data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img"
# - all parameter are optional
# - use the parameter "image_file_on_the_pc" to copy the image file created to the PC
# - use the parameter twrp=twrp_image to select a specific TWRP image if booting from the TWRP image is necessary or requested via parameter
# - use the parameter "twrp" to force a reboot into the TWRP image even if adb access is working
# - use the parameter "notwrp" to disable booting into the TWRP image 
# - the task boots the phone from the TWRP image if necessary to create the backup
# - the parameter "reboot" is only processed if the phone is booted from the TWRP image
#
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_backup_boot_partition {
  typeset __FUNCTION="task_backup_boot_partition"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [twrp] [notwrp] [twrp=twrp_image] [image_file_on_the_phone] [image_file_on_the_pc] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset CUR_TWRP_IMAGE_FILE=""
  
  typeset SLOT_FOR_THIS_TASK=""

  typeset IMAGE_FILE_ON_THE_PHONE=""
  typeset IMAGE_FILE_ON_THE_PC=""

  typeset ACCESS_OKAY=${__FALSE}
  typeset ROOT_PREFIX=""

  typeset PARTITION_FILE_CHECK_SUM=""
  typeset PARTITION_CHECK_SUM=""

  typeset LOCAL_FILE_CHECK_SUM=""

  typeset CUR_BOOT_PARTITION=""

  typeset FORCE_BOOT_INTO_TWRP=${__FALSE}
  
  typeset TWRP_BOOT_DISABLED=${__FALSE}
  
  typeset PHONE_BOOTED_INTO_TWRP=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      
      notwrp  | no_twrp )
        TWRP_BOOT_DISABLED=${__TRUE}
        ;;

      twrp )
        FORCE_BOOT_INTO_TWRP=${__TRUE}
        ;;

      twrp=* )
        CUR_TWRP_IMAGE_FILE="${PARAMETER_VAL}"
        ;;

      pc=* | PC=* )
        if [ "${IMAGE_FILE_ON_THE_PC}"x = ""x ] ; then
          IMAGE_FILE_ON_THE_PC="${PARAMETER_VAL}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;

      phone=* | PHONE=* )
        if [ "${IMAGE_FILE_ON_THE_PHONE}"x = ""x ] ; then
          IMAGE_FILE_ON_THE_PHONE="${PARAMETER_VAL}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;


      * )
        if [ "${IMAGE_FILE_ON_THE_PHONE}"x = ""x ] ;then
          IMAGE_FILE_ON_THE_PHONE="${CUR_TASK_PARAMETER}"
        elif [ "${IMAGE_FILE_ON_THE_PC}"x = ""x ] ; then
          IMAGE_FILE_ON_THE_PC="${CUR_TASK_PARAMETER}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}

          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;
     esac
  done

  if [ "${IMAGE_FILE_ON_THE_PHONE}"x = ""x ] ;then
    LogMsg "Imagefile not defined in the parameter -- using the default image file"

    IMAGE_FILE_ON_THE_PHONE="default"
    
#    LogErrorMsg "The task parameter for the image file on the phone is missing"
#    PRINT_TASK_USAGE=${__TRUE}
#    THISRC=${__FALSE}
  fi

  [ "${IMAGE_FILE_ON_THE_PC}"x = "none"x ] && IMAGE_FILE_ON_THE_PC=""

  [ "${SLOT_FOR_THIS_TASK}"x = ""x ] && SLOT_FOR_THIS_TASK="current"
  if [ "${CUR_TWRP_IMAGE_FILE}"x != ""x ] ; then
    get_twrp_image_for_the_installed_OS
    if [ "${TEMP_TWRP_IMAGE_TO_USE}"x != ""x ] ; then
      CUR_TWRP_IMAGE_FILE="${TEMP_TWRP_IMAGE_TO_USE}"
    else
      CUR_TWRP_IMAGE_FILE="${TWRP_IMAGE}"
    fi
  fi
  
#  CUR_TWRP_IMAGE_FILE="${CUR_TWRP_IMAGE_FILE:=${TWRP_IMAGE}}"

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Creating a backup of a boot partition ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the task is enabled"
    else      
      LogMsg "The automatic reboot after executing the task is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi
        
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    BOOT_SLOT=""

    retrieve_phone_status

    print_phone_status

    SLOT_FOR_THIS_TASK="$( get_slot_for_this_task "${SLOT_FOR_THIS_TASK}" )"
      
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
   if [ "${IMAGE_FILE_ON_THE_PHONE}"x = "default"x ] ; then
     IMAGE_FILE_ON_THE_PHONE="/data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img"
   fi
   
   LogMsg "Creating an image file of the partition \"boot${SLOT_FOR_THIS_TASK}\" in the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone"
    if [ "${IMAGE_FILE_ON_THE_PC}"x != ""x ] ; then
      LogMsg "The file \"${IMAGE_FILE_ON_THE_PHONE}\" is copied to the file \"${IMAGE_FILE_ON_THE_PC}\" on the PC"
    fi
  fi

# ---------------------------------------------------------------------

  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Retrieving the current status of the phone ..."
    
#  PHONE_STATUS can be:
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell
    
    case ${PHONE_STATUS} in 


      1 | 2 | 7 )
        LogMsg "The phone is booted from a recovery or TWRP image with root access"
        ACCESS_OKAY=${__TRUE}
        PHONE_BOOTED_INTO_TWRP=${__TRUE}
        ;;

      3 | 6 )
        check_root_access silent
        if [ $? = ${__FALSE} ] ; then
          LogMsg "The phone is booted into the Android OS without root access"
          ACCESS_OKAY=${__FALSE}
        elif [ "${ROOT_ACCESS_PREFIX}"x = ""x ] ; then
          LogMsg "The phone is booted into the Android OS with root access"
          ACCESS_OKAY=${__TRUE}        
        else
          ROOT_PREFIX="${ROOT_ACCESS_PREFIX}"
          LogMsg "The phone is booted into the Android OS with root access via \"${ROOT_PREFIX}\" "
          ACCESS_OKAY=${__TRUE}
        fi
        ;;

      4 | 5 | 8 )
        ACCESS_OKAY=${__FALSE}
        ;;

      * )
        LogErrorMsg "Access to the phone does currently not work"
        THISRC=${__FALSE}
        ;;

    esac

  fi
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${FORCE_BOOT_INTO_TWRP} = ${__TRUE} ] ; then
      LogMsg "Rebooting into TWRP requested via task parameter \"twrp\" "
      ACCESS_OKAY=${__FALSE}
    fi
    
    if [ ${ACCESS_OKAY} = ${__FALSE} -o ${FORCE_BOOT_INTO_TWRP} = ${__TRUE} ] ; then
    
      if [ ${TWRP_BOOT_DISABLED} = ${__TRUE} ] ; then
        LogWarningMsg "Booting from the TWRP image disabled with the task parameter \"notrwp\" "
        
        THISRC=${__FALSE}
      else
        LogMsg "Now rebooting the phone from the TWRP image \"${CUR_TWRP_IMAGE_FILE}\" ..."

        ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image "${CUR_TWRP_IMAGE_FILE}" 

        PHONE_BOOTED_INTO_TWRP=${__TRUE}

        retrieve_phone_status

        print_phone_status      
    
        if [ ${PHONE_STATUS} != 1 ] ; then
          LogErrorMsg "Error booting the phone from the TWRP image \"${CUR_TWRP_IMAGE_FILE}\""
          THISRC=${__FALSE}
        else
          ACCESS_OKAY=${__TRUE}
          ROOT_PREFIX=""
        fi
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    CUR_BOOT_PARTITION="/dev/block/by-name/boot${SLOT_FOR_THIS_TASK}"

    if [[ ${IMAGE_FILE_ON_THE_PHONE%/*} == /data/recovery ]] ; then
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} mkdir -p ${IMAGE_FILE_ON_THE_PHONE%/*}  2>&1 )"    
    fi

    LogMsg "Creating a backup of the partition \"${CUR_BOOT_PARTITION}\" into the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone ..."
    CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} dd if=${CUR_BOOT_PARTITION} of=${IMAGE_FILE_ON_THE_PHONE}  2>&1 )"    
    TEMPRC=$?
    LogMsg "-" "${CUR_OUTPUT}"
    
    if [ "${TEMPRC}" != 0 ] ; then
      LogErrorMsg "Error creating a backup of the partition \"${CUR_BOOT_PARTITION}\" into the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone"
      THISRC=${__FALSE}
    else
      LogMsg " .. image file \"${IMAGE_FILE_ON_THE_PHONE}\" successfully created"
      
      LogMsg "Creating the check sum of the boot partition \"${CUR_BOOT_PARTITION}\" ..."
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} cksum ${CUR_BOOT_PARTITION} 2>&1 )"
      TEMPRC=$?
      
      LogMsg "-" "${CUR_OUTPUT}"
      
      if [ ${TEMPRC} != 0 ] ; then
        LogErrorMsg "Error creating the check sum for the partition \"${CUR_BOOT_PARTITION}\" "
        THISRC=${__FALSE}
      else

        PARTITION_CHECK_SUM="${CUR_OUTPUT%% *}"

        LogMsg "Creating the check sum of the image file \"${IMAGE_FILE_ON_THE_PHONE}\" ...."
        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} cksum ${IMAGE_FILE_ON_THE_PHONE}  2>&1 )"    
        TEMPRC=$?

        LogMsg "-" "${CUR_OUTPUT}"

        PARTITION_FILE_CHECK_SUM="${CUR_OUTPUT%% *}"

        if [ ${TEMPRC} != 0 ] ; then
          LogErrorMsg "Error creating the check sum for the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone "
          THISRC=${__FALSE}
        elif [ "${PARTITION_CHECK_SUM}"x != "${PARTITION_FILE_CHECK_SUM}"x ] ; then
          LogErrorMsg "The check sum for the partition \"${CUR_BOOT_PARTITION}\" does not match the check sum for the image file \"${IMAGE_FILE_ON_THE_PHONE}\""
          THISRC=${__FALSE}
        else
          LogMsg "OK, the check sum for the partition \"${CUR_BOOT_PARTITION}\" is equal to the check sum for the image file \"${IMAGE_FILE_ON_THE_PHONE}\""
        fi
      fi
    fi
  fi
  

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${IMAGE_FILE_ON_THE_PC}"x != ""x ] ; then
    
      [ -d "${IMAGE_FILE_ON_THE_PC}" ] && IMAGE_FILE_ON_THE_PC="${IMAGE_FILE_ON_THE_PC}/${IMAGE_FILE_ON_THE_PHONE##*/}"
      LogMsg "Copying the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone to the file \"${IMAGE_FILE_ON_THE_PC}\" on the PC ..."
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} cat "${IMAGE_FILE_ON_THE_PHONE}"  >"${IMAGE_FILE_ON_THE_PC}" )"  
      TEMPRC=$?

      if [ ${TEMPRC} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Error copying the file \"${IMAGE_FILE_ON_THE_PHONE}\" on the phone to the file \"${IMAGE_FILE_ON_THE_PC}\" on the PC"
        THISRC=${__FALSE}
      else
        LogMsg "Checking the check sum of the file \"${IMAGE_FILE_ON_THE_PC}\" ..."

        CUR_OUTPUT="$( cksum ${IMAGE_FILE_ON_THE_PC} 2>&1 )"
        TEMPRC=$?

        LogMsg "-" "${CUR_OUTPUT}"

        LOCAL_FILE_CHECK_SUM="${CUR_OUTPUT%% *}"

        if [ ${TEMPRC} != 0 ] ; then
          LogErrorMsg "Error checking the check sum of the file \"${IMAGE_FILE_ON_THE_PC}\" "
          THISRC=${__FALSE}
        elif [ "${LOCAL_FILE_CHECK_SUM}"x != "${PARTITION_FILE_CHECK_SUM}"x ] ; then
          LogErrorMsg "The check sum for the local file \"${IMAGE_FILE_ON_THE_PC}\" does not match the check sum for the image file \"${IMAGE_FILE_ON_THE_PHONE}\""
          THISRC=${__FALSE}
        else
          LogMsg "OK, the check sum of the file \"${IMAGE_FILE_ON_THE_PC}\" is okay"
        fi
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ ${PHONE_BOOTED_INTO_TWRP} = ${__TRUE} ] ; then
      if [ "${REBOOT}"x = "yes"x ] ; then
        LogMsg "*** Now rebooting the phone ..."
        reboot_phone wait force
      else
        LogMsg "Rebooting the phone was NOT requested via task parameter"
      fi
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_restore_boot_partition
#
# function: restore the a boot partition from an image file
#
# usage: task_restore_boot_partition [slot] [reboot|reboot=no|reboot=yes] [ignorerc]  [twrp] [twrp=twrp_image] [[pc=|phone=]image_file] 
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the default image file used for the recovery is "/data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img"
# - use the parameter "pc=image_file" for image files on the PC; use "phone=image_file" or "image_file" for image files on the phone
# - use the parameter "twrp" to force a reboot into the TWRP image even if adb access is working
# - use the parameter twrp=twrp_image to select a specific TWRP image if booting from the TWRP image is necessary or requested via parameter
#
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_restore_boot_partition {
  typeset __FUNCTION="task_restore_boot_partition"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [twrp] [twrp=twrp_image] [[pc=|phone=]image_file]  "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset CUR_TWRP_IMAGE_FILE=""
  
  typeset SLOT_FOR_THIS_TASK=""

  typeset BOOT_PARTITION_IMAGE_FILE=""

# default: the image file to use is on the phone
#
  typeset IMAGE_FILE_IS_ON_THE_PC=${__FALSE}
  typeset IMAGE_FILE_LOCATION="phone"

    
  typeset ACCESS_OKAY=${__FALSE}
  typeset ROOT_PREFIX=""

  typeset PARTITION_FILE_CHECK_SUM=""
  typeset PARTITION_CHECK_SUM=""

  typeset LOCAL_FILE_CHECK_SUM=""

  typeset CUR_BOOT_PARTITION=""

  typeset FORCE_BOOT_INTO_TWRP=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      twrp )
        FORCE_BOOT_INTO_TWRP=${__TRUE}
        ;;

      twrp=* )
        CUR_TWRP_IMAGE_FILE="${PARAMETER_VAL}"
        ;;

      pc=* | PC=* | phone=* | PHONE=* )
        if [ "${BOOT_PARTITION_IMAGE_FILE}"x = ""x ] ;then
          BOOT_PARTITION_IMAGE_FILE="${PARAMETER_VAL}"

          if [ "${PARAMETER_KEY}" = "pc" -o "${PARAMETER_KEY}" = "PC" ] ; then
            IMAGE_FILE_IS_ON_THE_PC=${__TRUE}
            IMAGE_FILE_LOCATION="PC"
          fi
          
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}

          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;
      
      * )
        if [ "${BOOT_PARTITION_IMAGE_FILE}"x = ""x ] ;then
          BOOT_PARTITION_IMAGE_FILE="${CUR_TASK_PARAMETER}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}

          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;
     esac
  done


  if [ "${BOOT_PARTITION_IMAGE_FILE}"x = ""x ] ; then
    LogMsg "Imagefile not defined in the parameter -- using the default image file"

    BOOT_PARTITION_IMAGE_FILE="default"
    
#    LogErrorMsg "The task parameter for the image file is missing"
#    PRINT_TASK_USAGE=${__TRUE}
#    THISRC=${__FALSE}
  fi

  [ "${SLOT_FOR_THIS_TASK}"x = ""x ] && SLOT_FOR_THIS_TASK="current"

  CUR_TWRP_IMAGE_FILE="${CUR_TWRP_IMAGE_FILE:=${TWRP_IMAGE}}"

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Restoring a boot partition from an image file ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the task is enabled"
    else      
      LogMsg "The automatic reboot after executing the task is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the tasks ends with a return code not zero"
    fi
        
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    BOOT_SLOT=""

    retrieve_phone_status

    print_phone_status

    SLOT_FOR_THIS_TASK="$( get_slot_for_this_task "${SLOT_FOR_THIS_TASK}" )"
      
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

   if [ "${BOOT_PARTITION_IMAGE_FILE}"x = "default"x ] ; then
     BOOT_PARTITION_IMAGE_FILE="/data/recovery/initial_boot${SLOT_FOR_THIS_TASK}.img"
   fi
  
   LogMsg "Restoring the partition \"boot${SLOT_FOR_THIS_TASK}\" from the file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION}"
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Retrieving the current status of the phone ..."
    
#  PHONE_STATUS can be:
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell
    
    case ${PHONE_STATUS} in 

      1 | 2 | 7 )
        LogMsg "The phone is booted from a recovery or TWRP image with root access"
        ACCESS_OKAY=${__TRUE}
        ;;

      3 | 6 )
        check_root_access silent
        if [ $? = ${__FALSE} ] ; then
          LogMsg "The phone is booted into the Android OS without root access"
          ACCESS_OKAY=${__FALSE}
        elif [ "${ROOT_ACCESS_PREFIX}"x = ""x ] ; then
          LogMsg "The phone is booted into the Android OS with root access"
          ACCESS_OKAY=${__TRUE}        
        else
          ROOT_PREFIX="${ROOT_ACCESS_PREFIX}"
          LogMsg "The phone is booted into the Android OS with root access via \"${ROOT_PREFIX}\" "
          ACCESS_OKAY=${__TRUE}
        fi
        ;;

      4 | 5 | 8 )
        ACCESS_OKAY=${__FALSE}
        ;;

      * )
        LogErrorMsg "Access to the phone does currently not work"
        THISRC=${__FALSE}
        ;;

    esac

  fi
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ ${FORCE_BOOT_INTO_TWRP} = ${__TRUE} ] ; then
      LogMsg "Rebooting into TWRP requested via task parameter \"twrp\" "
      ACCESS_OKAY=${__FALSE}
    fi
    
    if [ ${ACCESS_OKAY} = ${__FALSE} ] ; then
      LogMsg "Now rebooting the phone from the TWRP image \"${CUR_TWRP_IMAGE_FILE}\" ..."

      ${PREFIX_FOR_THE_COMMANDS} boot_phone_from_the_TWRP_image "${CUR_TWRP_IMAGE_FILE}" 

      retrieve_phone_status

      print_phone_status      
    
      if [ ${PHONE_STATUS} != 1 ] ; then
        LogErrorMsg "Error booting the phone from the TWRP image \"${CUR_TWRP_IMAGE_FILE}\""
        THISRC=${__FALSE}
      else
        ACCESS_OKAY=${__TRUE}
        ROOT_PREFIX=""
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Checking the image file \"${BOOT_PARTITION_IMAGE_FILE}\" ..."

    if [ ${IMAGE_FILE_IS_ON_THE_PC} = ${__TRUE} ] ; then
      test -f "${BOOT_PARTITION_IMAGE_FILE}"  2>/dev/null ; TEMPRC=$?

      [ ${TEMPRC} = 0 ] && CUR_OUTPUT="$( cksum "${BOOT_PARTITION_IMAGE_FILE}"  2>/dev/null )"
      [ ${TEMPRC} = 0 ] && CUR_IMAGEFILE_TYPE="$( file "${BOOT_PARTITION_IMAGE_FILE}"  2>/dev/null | cut -f2- -d":" )"
    else
      ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} test -f "${BOOT_PARTITION_IMAGE_FILE}" 2>/dev/null ; TEMPRC=$?

      [ ${TEMPRC} = 0 ] && CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} cksum "${BOOT_PARTITION_IMAGE_FILE}"  2>&1 )"
      [ ${TEMPRC} = 0 ] && CUR_IMAGEFILE_TYPE="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} file "${BOOT_PARTITION_IMAGE_FILE}" 2>/dev/null | cut -f2- -d":" )"
    fi     
    
    if [ "${TEMPRC}" != 0 ] ; then
      LogErrorMsg "The file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} does not exist"
      THISRC=${__FALSE}
    elif [[ ${CUR_IMAGEFILE_TYPE} != *Android\ boot* ]] ; then
      LogErrorMsg "The file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} is not an Android boot image: \"${CUR_IMAGEFILE_TYPE}\" "
      THISRC=${__FALSE}
    else
      LogMsg "The check sum of the file  \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} is:"
      LogMsg "-" "${CUR_OUTPUT}"

      LogMsg "The type of the file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} is: \"${CUR_IMAGEFILE_TYPE}\" "
     
      PARTITION_FILE_CHECK_SUM="${CUR_OUTPUT%% *}"

#      LogMsg "The check sum for the file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} is ${PARTITION_FILE_CHECK_SUM}"
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    CUR_BOOT_PARTITION="/dev/block/by-name/boot${SLOT_FOR_THIS_TASK}"

    LogMsg "Restoring the partition \"${CUR_BOOT_PARTITION}\" from the file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION} ..."
    
    if [ ${IMAGE_FILE_IS_ON_THE_PC} = ${__TRUE} ] ; then
      CUR_OUTPUT="$( dd if="${BOOT_PARTITION_IMAGE_FILE}"  | ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} dd of=${CUR_BOOT_PARTITION} 2>&1 )"    
      TEMPRC=$?
    else
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} dd if="${BOOT_PARTITION_IMAGE_FILE}" of=${CUR_BOOT_PARTITION}   2>&1 )"    
      TEMPRC=$?
    fi
    
    LogMsg "-" "${CUR_OUTPUT}"
    
    if [ "${TEMPRC}" != 0 ] ; then
      LogErrorMsg "Error restoring the partition \"${CUR_BOOT_PARTITION}\" from the file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION}"
      THISRC=${__FALSE}
    else
      LogMsg " .. partition \"${CUR_BOOT_PARTITION}\" successfully restored"
      
      LogMsg "Creating the check sum of the boot partition \"${CUR_BOOT_PARTITION}\" ..."
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${ROOT_PREFIX} cksum ${CUR_BOOT_PARTITION} 2>&1 )"
      TEMPRC=$?
      
      LogMsg "-" "${CUR_OUTPUT}"
      
      if [ ${TEMPRC} != 0 ] ; then
        LogErrorMsg "Error creating the check sum for the partition \"${CUR_BOOT_PARTITION}\" "
        THISRC=${__FALSE}
      else

        PARTITION_CHECK_SUM="${CUR_OUTPUT%% *}"

        if [ "${PARTITION_CHECK_SUM}"x != "${PARTITION_FILE_CHECK_SUM}"x ] ; then
          LogErrorMsg "The check sum for the partition \"${CUR_BOOT_PARTITION}\" does not match the check sum for the image file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION}"
          THISRC=${__FALSE}
        else
          LogMsg "OK, the check sum for the partition \"${CUR_BOOT_PARTITION}\" is equal to the check sum for the image file \"${BOOT_PARTITION_IMAGE_FILE}\" on the ${IMAGE_FILE_LOCATION}"
        fi
      fi
    fi
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------


  
# ----------------------------------------------------------------------
# task_select_twrp_image - select the TWRP image depending on the OS installed on the phone
#
# function: select the TWRP image depending on the OS installed on the phone
#
# usage: task_select_twrp_image [ignorerc]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the phone must be booted into the Android OS with working adb connection 
# - the task ends with RC=${__FALSE} if it's not possible to define a valid TWRP image (use the parameter "ignorerc" to always end with RC=${__TRUE})
#
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_select_twrp_image {
  typeset __FUNCTION="task_select_twrp_image"
  typeset TASK_USAGE="${__FUNCTION} "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
  typeset IGNORE_RC=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset TWRP_IMAGE_TO_USE=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
      
      * )            
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac

  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Selecting the TWRP image to use depending on the installed OS on the phone ..."
    LogMsg ""

    retrieve_phone_status

    print_phone_status

    if [ "${TEMP_TWRP_IMAGE_TO_USE}"x != ""x ] ; then
      TWRP_IMAGE_TO_USE="${TEMP_TWRP_IMAGE_TO_USE}"
    else
      TWRP_IMAGE_TO_USE="${TWRP_IMAGE}"
    fi
  fi

  if [ ${THISRC} = ${__TRUE} ] ; then
    TWRP_IMAGE="${TWRP_IMAGE_TO_USE}"
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      LogMsg "Ignoring the return code of the task is requested via task parameter"
      LogMsg "The TWRP image to use is \"${TWRP_IMAGE}\""
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}




# ----------------------------------------------------------------------
# task_execute_command_on_the_phone
#
# function: execute a command on the phone via "adb shell ..."
#
# usage: task_execute_command_on_the_phone [ignorerc] [command_to_execute]  
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_execute_command_on_the_phone {
  typeset __FUNCTION="task_execute_command_on_the_phone"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc]  [command_to_execute]  # no default, no whitepspaces allowed; execute w/o task parameter to open an interactive shell"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset CUR_TWRP_IMAGE_FILE=""
  
  typeset SLOT_FOR_THIS_TASK=""

  typeset BOOT_PARTITION_IMAGE_FILE=""

# default: the image file to use is on the phone
#
  typeset IMAGE_FILE_IS_ON_THE_PC=${__FALSE}
  typeset IMAGE_FILE_LOCATION="phone"

  typeset COMMAND_TO_EXECUTE=""
    
  typeset ACCESS_OKAY=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      * )
        if [ "${COMMAND_TO_EXECUTE}"x = ""x ] ;then
          COMMAND_TO_EXECUTE="${CUR_TASK_PARAMETER}"
        else
          COMMAND_TO_EXECUTE="${COMMAND_TO_EXECUTE} ; ${CUR_TASK_PARAMETER}"

#          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found: \"${CUR_TASK_PARAMETER}\" "
#          THISRC=${__FALSE}
#          CONT=${__FALSE}

#          PRINT_TASK_USAGE=${__TRUE}
        fi
        ;;
     esac
  done

  if [ "${COMMAND_TO_EXECUTE}"x = ""x ] ; then
    LogMsg "No command to execute found in the parameter - now starting an interactive shell"
  fi

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    LogMsg ""
    LogMsg "*** Executing a command on the phone ..."
    LogMsg ""
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the tasks ends with a return code not zero"
    fi
        
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "The command(s) to execute on the phone are:"
    LogMsg "-"
    LogMsg "-" "${COMMAND_TO_EXECUTE}"
    LogMsg "-"

    retrieve_phone_status

    print_phone_status
      
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Retrieving the current status of the phone ..."
    
#  PHONE_STATUS can be:
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the LineageOS recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell

    case ${PHONE_STATUS} in 

      1 | 2 | 7 | 3 | 6 )
        LogMsg "The phone is booted from a recovery or TWRP image wi"
        ACCESS_OKAY=${__TRUE}
        ;;

      4 | 5 | 8 )
        LogErrorMsg "The phone is booted into a mode without access via adb"
        ACCESS_OKAY=${__FALSE}
        ;;

      * )
        LogErrorMsg "Access to the phone does currently not work"
        THISRC=${__FALSE}
        ;;

    esac

  fi
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${COMMAND_TO_EXECUTE}"x = ""x ] ; then
      LogMsg "Starting a shell on the phone ..."
      ${ADB} ${ADB_OPTIONS} shell
      TEMPRC=$?
    else
      LogMsg "Executing now "
      LogMsg "-" "${COMMAND_TO_EXECUTE}"
      LogMsg "on the phone ..."

      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell ${COMMAND_TO_EXECUTE} 2>&1 )"
      TEMPRC=$?
      LogMsg "-"
      LogMsg "-" "${CUR_OUTPUT}"    
      LogMsg "-"
    
    fi    

    LogMsg "The returncode is ${TEMPRC}"

    if [ "${TEMPRC}" != 0 ] ; then

      LogErrorMsg "Error executing the command on the phone"
      THISRC=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_install_ASUS_raw_image
#
# function: install a raw OS image from ASUS on the phone
#
# usage: task_install_ASUS_raw_image [reboot|reboot=no|reboot=yes] [ignorerc] [dir_with_raw_image]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_install_ASUS_raw_image {
  typeset __FUNCTION="task_install_ASUS_raw_image"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [dir_with_raw_image] [paremeter_for_the_install_script]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset CUR_RAW_IMAGE_DIR=""
  
  typeset UPDATE_SCRIPT="update_image.sh"
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [ "${CUR_RAW_IMAGE_DIR}"x = ""x ] ; then
          CUR_RAW_IMAGE_DIR="${CUR_TASK_PARAMETER}"
        else
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi

#            LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the \"${PARAMETER_KEY}\" to use found: \"${CUR_TASK_PARAMETER}\" "
#            THISRC=${__FALSE}
#            CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${CUR_RAW_IMAGE_DIR}"x = ""x ] ; then
      CUR_RAW_IMAGE_DIR="${DEFAULT_CUR_RAW_IMAGE_DIR}"
    fi

    if [ "${CUR_RAW_IMAGE_DIR}"x = ""x ] ; then
      LogErrorMsg "No raw image to install defined"
      THISRC=${__FALSE}
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then    
    LogMsg "Installing the Android raw image from the directory \"${CUR_RAW_IMAGE_DIR}\" "

    if [ ! -r "${CUR_RAW_IMAGE_DIR}" ] ; then
      LogErrorMsg "The directory \"${CUR_RAW_IMAGE_DIR}\" does not exist"
      THISRC=${__FALSE}
    elif [ ! -d "${CUR_RAW_IMAGE_DIR}" ] ; then
      LogErrorMsg "\"${CUR_RAW_IMAGE_DIR}\" is NOT a directory:"
      LogMsg "-" "$( ls -ld "${CUR_RAW_IMAGE_DIR}" )"
      THISRC=${__FALSE}
    else
      cd "${CUR_RAW_IMAGE_DIR}"
      if [ $? -ne 0 ] ; then
        LogErrorMsg "Can not change the current working directory to \"${CUR_RAW_IMAGE_DIR}\" "
        THISRC=${__FALSE}
      else
        if [ ! -x "${UPDATE_SCRIPT}" ] ; then
          LogErrorMsg "The script \"${UPDATE_SCRIPT}\" does not exist in the directory \"${CUR_RAW_IMAGE_DIR}\" "
          THISRC=${__FALSE}
        fi
      fi
    fi
  fi
  
# ---------------------------------------------------------------------

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then    
   
    CMD_PARAMETER=" noreboot ${CMD_PARAMETER} "
    
    CUR_SCRIPT="${CUR_RAW_IMAGE_DIR}/${UPDATE_SCRIPT}"
    
    LogMsg ""
    LogMsg "*** Installing the Android raw OS image in the directory \"${CUR_RAW_IMAGE_DIR}\" using the script \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
      IGNORE_SCRIPT_RC=${__FALSE}
    fi

    reboot_phone bootloader wait

    retrieve_phone_status

    print_phone_status    

    if [ ${PHONE_STATUS} != 4 ] ; then
      LogErrorMsg "Booting the phone into the bootloader failed"
      THISRC=${__FALSE}
    else
      execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
      THISRC=$?
    fi    

  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_select_twrp_image_for_install_image
#
# function: select a TWRP image to be used for an OS image file
#
# usage: task_select_twrp_image_for_install_image [ignorerc] [image_file]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - without a parameter the task selects the TWRP image necessary for the OS image file defined in the global variable "${OS_IMAGE_TO_INSTALL}
# - define the environment variable ${NEW_TWRP_IMAGE} to disable the auto select of the TWRP image in this task
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_select_twrp_image_for_install_image {
  typeset __FUNCTION="task_select_twrp_image_for_install_image"
  typeset TASK_USAGE="${__FUNCTION} [ignorerc] [image_file] # default ${OS_IMAGE_FILE}"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset CUR_IMAGE_FILE=""
  typeset CUR_TWRP_FILE=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;
      
      * )    
        if [ "${CUR_IMAGE_FILE}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter for the OS image file found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_IMAGE_FILE="${CUR_TASK_PARAMETER}"
        fi

#          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
#          PRINT_TASK_USAGE=${__TRUE}
#          THISRC=${__FALSE}
#          CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    if [ "${CUR_IMAGE_FILE}"x = ""x ] ; then
      CUR_IMAGE_FILE="${OS_IMAGE_TO_INSTALL}"
    fi
    
    LogMsg ""
    LogMsg "*** Selecting the TWRP image to use based for the OS installed using the image file  \"${CUR_IMAGE_FILE}\"  ..."
    LogMsg ""

    if [ "${NEW_TWRP_IMAGE}"x != ""x ] ; then
      LogMsg "The environment variable NEW_TWRP_IMAGE is set - using the contents of that variable"

      CUR_TWRP_IMAGE_FILE="${NEW_TWRP_IMAGE}"
    else

      select_twrp_image_for_install_image "${CUR_IMAGE_FILE}"
      THISRC=$?
      
      if [ ${THISRC} -eq ${__TRUE} ] ; then
  
# 
# change the global variable for the TWRP image to be used
#    

# ??? 22.07.2024
set -x

#
# 02.09.2024: force the next boot from the TWRP image for the new installed OS
#
        export TWRP_IMAGE_FOR_NEW_OS="${TEMP_TWRP_IMAGE_TO_USE}"


        export TWRP_IMAGE="${TEMP_TWRP_IMAGE_TO_USE}"
set +x
      fi
  
      LogMsg "The TWRP image to be used for the OS installed with the image file \"${CUR_IMAGE_FILE}\" is \"${TWRP_IMAGE}\" "
      
      if [ ${IGNORE_RC} = ${__TRUE} ]; then
        LogMsg "The Returncode of the script is ignored"
      else
        LogMsg "The task execution stops if the script ends with a return code not zero"
      fi
    fi 
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_DebugShell
#
# function: call the DebugShell
#
# usage: task_DebugShell
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_DebugShell {
  typeset __FUNCTION="task_DebugShell"
  typeset TASK_USAGE="${__FUNCTION} "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      * )    
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    
    LogMsg ""
    LogMsg "*** Calling a DebugShell now ..."
    LogMsg ""
    
    DebugShell
        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_copy_file_to_phone
#
# function: copy a file to the phone
#
# usage: task_copy_file_to_phone  [reboot|reboot=no|reboot=yes] [ignorerc] [source_file] [target_file|target_dir]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_copy_file_to_phone {
  typeset __FUNCTION="task_copy_file_to_phone"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [source_file] [target_file|target_dir] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

  typeset SOURCE_FILE=""
  typeset TARGET_FILE=""
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [ "${SOURCE_FILE}"x = ""x ] ; then
          SOURCE_FILE="${CUR_TASK_PARAMETER}"
        elif [ "${TARGET_FILE}"x = ""x ] ; then
          TARGET_FILE="${CUR_TASK_PARAMETER}"
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: To many task parameter used"
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi    
        ;;

#          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
#          PRINT_TASK_USAGE=${__TRUE}
#          THISRC=${__FALSE}
#          CONT=${__FALSE}

     esac
  done

  if [ "${SOURCE_FILE}"x = ""x ] ; then
    LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the source file is missing"
    THISRC=${__FALSE}
    PRINT_TASK_USAGE=${__TRUE}
  fi

  if [ "${TARGET_FILE}"x = ""x ] ; then
    LogErrorMsg "Task ${__FUNCTION#task_*}: The parameter for the target file is missing"
    THISRC=${__FALSE}
    PRINT_TASK_USAGE=${__TRUE}
  fi
   
  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
  
    LogMsg ""
    LogMsg "*** Copying the file \"${SOURCE_FILE}\" to \"${TARGET_FILE}\" on the phone ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ ! -r "${SOURCE_FILE}" ] ; then
      LogErrorMsg "The file \"${SOURCE_FILE}\" does not exist"
      THISRC=${__FALSE}
    else
      
      case ${PHONE_STATUS} in
      
        1 | 2 | 3 | 6 | 7  )

          CUR_OUTPUT="$( set -x ; ${ADB} ${ADB_OPTIONS} push "${SOURCE_FILE}" "${TARGET_FILE}" 2>&1 )"
          TEMPRC=$?
          LogMsg "-"
          LogMsg "-" "${CUR_OUTPUT}"    
          LogMsg "-"
          if [ ${TEMPRC} != 0 ] ; then
            LogErrorMsg "Error copying the file \"${SOURCE_FILE}\" to \"${TARGET_FILE}\" on the phone"
            THISRC=${__FALSE}
          else
            LogMsg  "Successfully copied the file \"${SOURCE_FILE}\" to \"${TARGET_FILE}\" on the phone"
          fi
          ;;
          
        * )
          echo "ERROR: There is no working adb connection to the phone"
          THISRC=${__FALSE}
          ;;
      esac
    fi
        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}


# ----------------------------------------------------------------------
# task_reset_usb_port
#
# function: reset an usb port 
#
# usage: task_reset_usb_port [reboot|reboot=no|reboot=yes] [ignorerc] [force] [usb_port] [...]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# If you use the task with no or only one USB port in the parameter, the task will only reset the port if necessary.
# When using the task with several parameters for USB ports or the parameter "force", the task always resets the ports.
# The script uses sudo to reset the USB ports if executed by a non-root user
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_reset_usb_port {
  typeset __FUNCTION="task_reset_usb_port"
  typeset TASK_USAGE="${__FUNCTION} [reboot|reboot=no|reboot=yes] [ignorerc] [force] [usb_port] [...] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset USB_PORTS_TO_RESET=""
  typeset CUR_USB_PORT=""
  typeset NO_OF_USB_PORTS_TO_RESET=0
  
  typeset FORCE_RESET=${__FALSE}
  typeset PARAMETER_FORCE_FOUND=${__FALSE}
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      force )
        FORCE_RESET=${__TRUE}
        PARAMETER_FORCE_FOUND=${__TRUE}
        ;;

      * )    
        if [[  ${CUR_TASK_PARAMETER} == /* ]] ;then
          USB_PORTS_TO_RESET="${USB_PORTS_TO_RESET} ${CUR_TASK_PARAMETER}"
          (( NO_OF_USB_PORTS_TO_RESET = NO_OF_USB_PORTS_TO_RESET + 1 ))
        else
          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
          PRINT_TASK_USAGE=${__TRUE}
          THISRC=${__FALSE}
          CONT=${__FALSE}
        fi
        ;;
     esac
  done

  set_serial_number
  get_usb_device_for_the_phone
  if [ "${USB_PORTS_TO_RESET}"x = ""x ] ; then
    USB_PORTS_TO_RESET="${PHONE_USB_DEVICE}"
    NO_OF_USB_PORTS_TO_RESET=1
  fi

  if [ "${USB_PORTS_TO_RESET}"x = ""x ] ; then
    LogErrorMsg "No USB ports to reset defined"
    THISRC=${__FALSE}
    CONT=${__FALSE}
  fi

  if [ ${NO_OF_USB_PORTS_TO_RESET} = 1 -a ${PARAMETER_FORCE_FOUND} != ${__TRUE} ] ; then
    FORCE_RESET=${__FALSE}
  fi
  
  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi
  
# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg ""
    LogMsg "*** Resetting the USB port(s) \"${USB_PORTS_TO_RESET}\" ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
        
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi
    
    for CUR_USB_PORT in ${USB_PORTS_TO_RESET} ; do
      if [ ${FORCE_RESET} = ${__TRUE} ] ; then
        CUR_OUTPUT="$( reset_usb_port "${CUR_USB_PORT}" 2>&1 )"
        TEMPRC=$?        
      else
        retrieve_phone_status ${__FALSE}
        CUR_OUTPUT="$( reset_the_usb_port_for_the_phone_if_necessary "${CUR_USB_PORT}" 2>&1 )"
        TEMPRC=$?
      fi
      LogMsg "-" "${CUR_OUTPUT}"
      LogMsg "-"
      [ ${TEMPRC} != ${__TRUE} -a 0${PHONE_STATUS} -ge 10 ] && THISRC=${TEMPRC}
    done        
  fi

  if [ ${NO_OF_USB_PORTS_TO_RESET} = 1  ] ; then
    set_serial_number
    retrieve_phone_status ${__FALSE}
    print_phone_status
  fi
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_enable_disable_abort_on_error
#
# function: enable or disable aborting the task execution after an error
#
# usage: task_enable_disable_abort_on_error [yes|no|enable|disable]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_disable_abort_on_error {
  typeset __FUNCTION="task_enable_disable_abort_on_error"
  typeset TASK_USAGE="${__FUNCTION} [yes|no] # default is yes"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset NEW_VALUE=${__TRUE}
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      true | 0 | yes | enable )
         NEW_VALUE=${__TRUE}
         ;;

      false | 1 | no | disable )
         NEW_VALUE=${__FALSE}
         ;;


      * )           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    LogMsg "Setting the variable \"ABORT_TASK_EXECUTION_ON_ERROR\" to \"${NEW_VALUE}\" .."
    ABORT_TASK_EXECUTION_ON_ERROR=${NEW_VALUE}

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    LogInfo "Setting the variable \"ABORT_TASK_EXECUTION_ON_ERROR\" to \"${NEW_VALUE}\" .."
    ABORT_TASK_EXECUTION_ON_ERROR=${NEW_VALUE}
    
    if [ ${ABORT_TASK_EXECUTION_ON_ERROR} = ${__TRUE} ] ; then
      LogMsg "Enabling script abort after a task failed"
    else
      LogMsg "Disabling script abort a task failed"
    fi
  fi
    
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# enable single step on error for executing the tasks
#
ENABLE_SINGLE_STEP_ON_ERROR=${__TRUE}


# ----------------------------------------------------------------------
# task_enable_disable_singlestep_on_error
#
# function: enable or disable single-step after a task failed
#
# usage: task_enable_disable_singlestep_on_error [yes|no|enable|disable]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#


function task_enable_disable_singlestep_on_error {
  typeset __FUNCTION="task_enable_disable_singlestep_on_error"
  typeset TASK_USAGE="${__FUNCTION} [yes|no] # default is yes"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}

  typeset CUR_TASK_PARAMETER=""

  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT="${SCRIPT_DIR}/"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

  typeset NEW_VALUE=${__TRUE}
  
# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

    case ${CUR_TASK_PARAMETER} in

      true | 0 | yes | enable )
         NEW_VALUE=${__TRUE}
         ;;

      false | 1 | no | disable )
         NEW_VALUE=${__FALSE}
         ;;


      * )           
        LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
        PRINT_TASK_USAGE=${__TRUE}
        THISRC=${__FALSE}
        CONT=${__FALSE}
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    LogInfo "Setting the variable \"ENABLE_SINGLE_STEP_ON_ERROR\" to \"${NEW_VALUE}\" .."
    ENABLE_SINGLE_STEP_ON_ERROR=${NEW_VALUE}
    
    if [ ${ENABLE_SINGLE_STEP_ON_ERROR} = ${__TRUE} ] ; then
      LogMsg "Enabling automatic single-step after a task failed"
    else
      LogMsg "Disabling automatic single-step after a task failed"
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_send_notification_via_ntfy
#
# function: send a push message via ntfy
#
# usage: task_send_notification_via_ntfy topic message
#
# Before using this task install the app ntfy from 
#
#   https://f-droid.org/en/packages/io.heckel.ntfy/ 
#
# and subscribe to a topic on nfty.sh from within the app
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_send_notification_via_ntfy {
  typeset __FUNCTION="task_send_notification_via_ntfy"
  typeset TASK_USAGE="${__FUNCTION} topic message # for messages with whitespaces use MYVAR=\" message\" ${__FUNCTION} topic var=MYVAR "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset CUR_TOPIC=""
  
  typeset CUR_MESSAGE=""
  
  typeset NTFY_SERVER="ntfy.sh"
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  if [ $# -ne 0 ] ; then
    CUR_TOPIC="$1"
    shift
  fi

  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      var=* )
        eval CUR_MESSAGE=\"${CUR_MESSAGE} \$${PARAMETER_VAL}\"
        ;;
        
     * )
       CUR_MESSAGE="${CUR_MESSAGE} ${CUR_TASK_PARAMETER}" 
       
       ;;
    esac
  done     
  CUR_MESSAGE=${CUR_MESSAGE}
  
  if [ "${CUR_TOPIC}"x = ""x -o  "${CUR_MESSAGE}"x = ""x ] ; then
    LogErrorMsg "Parameter missing"
    THISRC=${__FALSE}
    PRINT_TASK_USAGE=${__TRUE}
  fi

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi
  
# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    LogMsg "Sending the notification \"${CUR_MESSAGE}\" to the topic \"${CUR_TOPIC}\" via \"${NTFY_SERVER}\" ..."
    CUR_OUTPUT="$( set -x ; curl -s -d "${CUR_MESSAGE}" "${NTFY_SERVER}/${CUR_TOPIC}" 2>&1 )"
    TEMPRC=$?
    LogMsg "-" "${CUR_OUTPUT}"

  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}

# ----------------------------------------------------------------------
# task_enable_adb_in_ramdisk
#
# function: enable adb in a ramdisk
#
# usage: task_enable_adb_in_ramdisk [slot] [reboot|reboot=no|reboot=yes] [ignorerc] [partition]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_enable_adb_in_ramdisk {
  typeset __FUNCTION="task_enable_adb_in_ramdisk"
  typeset TASK_USAGE="${__FUNCTION} [slot] [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [parameter_for_the_script] [partition]"
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""

  typeset SLOT_FOR_THIS_TASK=""

  typeset CMD_PARAMETER=""

  typeset SCRIPT_ON_THE_PHONE=""
  
  typeset CUR_SCRIPT_NAME="enable_adb_in_recovery_ramdisk.sh"
  
  typeset CUR_SCRIPT="${SCRIPT_DIR}/${CUR_SCRIPT_NAME}"

  typeset CUR_PARTITION=""
    
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      _a | _b | next | current | active | inactive )
        SLOT_FOR_THIS_TASK="${CUR_TASK_PARAMETER}"
        ;;

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [ "${CUR_PARTITION}"x != ""x ] ; then
          LogErrorMsg "Task ${__FUNCTION#task_*}: Duplicate parameter found: \"${CUR_TASK_PARAMETER}\" "
          THISRC=${__FALSE}
          CONT=${__FALSE}
        else
          CUR_PARTITION="${CUR_TASK_PARAMETER}"
        fi
        ;;
     esac
  done

  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    retrieve_phone_status ${__TRUE}
    
    print_phone_status
    
#     1 - the phone is already booted from the TWRP image
#     2 - the phone is booted from TWRP installed in the boot or recovery partition
#     3 - the phone is booted into the Android OS
#     4 - the phone is booted into bootloader 
#     5 - the phone is booted into the fastbootd
#     6 - the phone is booted into the safe mode of the Android OS
#     7 - the phone is booted into the a non-TWRP recovery installed in the boot or recovery partition
#     8 - the phone is booted into sideload mode
#     9 - the phone is booted into a recovery without working adb shell
    
    case ${PHONE_STATUS} in 
    
      1 | 2 | 7 )
        SCRIPT_ON_THE_PHONE="/tmp/${CUR_SCRIPT_NAME}"
        ;;

      3 | 6 )
        SCRIPT_ON_THE_PHONE="/data/local/tmp/${CUR_SCRIPT_NAME}"
        ;;
    
      * )
       LogErrorMsg "The adb access to the phone does not work"
       THISRC=${__FALSE}
       ;;
           
    esac
 
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    
    if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
      case ${SLOT_FOR_THIS_TASK} in

      current | active  )
        SLOT_FOR_THIS_TASK="${BOOT_SLOT}"
        ;;

      next | inactive )
        SLOT_FOR_THIS_TASK="${INACTIVE_SLOT}"
        ;;

      esac
      
      LogMsg "The slot to use for this task is \"${SLOT_FOR_THIS_TASK}\" "
    fi

    if [ "${CUR_PARTITION}"x = ""x ] ; then
      CUR_PARTITION="vendor_boot${BOOT_SLOT}"
    fi

    if [[ ${CUR_PARTITION} != *_a && ${CUR_PARTITION} != *_b ]] ; then
      if [ "${SLOT_FOR_THIS_TASK}"x != ""x ] ; then
        CUR_PARTITION="${CUR_PARTITION}${SLOT_FOR_THIS_TASK}"
      fi
    fi

    if [[ ${CUR_PARTITION} != /*  ]] ; then
      CUR_PARTITION="/dev/block/by-name/${CUR_PARTITION}"
    fi

    LogMsg ""
    LogMsg "*** Enabling adb in the ramdisk on the partition \"${CUR_PARTITION}\" using the script \"${CUR_SCRIPT}\" ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
    else
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi

    if [ ! -r "${CUR_SCRIPT}"  ] ; then
      LogErrorMsg "The script \"${CUR_SCRIPT}\" does not exist"
      THISRC=${__FALSE}
    else
      CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} push ${CUR_SCRIPT} ${SCRIPT_ON_THE_PHONE}  2>&1 )"
      TEMPRC=$?
      if [ ${TEMPRC} != 0 ] ; then
        LogMsg "-" "${CUR_OUTPUT}"
        LogErrorMsg "Error copying the script \"${CUR_SCRIPT}\" to \"${SCRIPT_ON_THE_PHONE}\" on the phone"
        THISRC=${__FALSE}
      else
        LogMsg "Executing the script \"${SCRIPT_ON_THE_PHONE}\" on the phone ..."
        
#        CUR_OUTPUT="$( ${ADB} ${ADB_OPTIONS} shell "VENDOR_BOOT_PARTITION=${CUR_PARTITION} ${SCRIPT_ON_THE_PHONE}" 2>61 )"
#        TEMPRC=$?
#        LogMsg "-" "${CUR_OUTPUT}"

        executeCommandAndLog ${ADB} ${ADB_OPTIONS} shell "VENDOR_BOOT_PARTITION=${CUR_PARTITION} ${SCRIPT_ON_THE_PHONE}"
        TEMPRC=$?

        if [ ${TEMPRC} -gt 1 ] ; then
          LogErrorMsg "Error executing the script \"${SCRIPT_ON_THE_PHONE}\" on the phone"
          THISRC=${__FALSE}
        else
          LogMsg "\"${SCRIPT_ON_THE_PHONE}\" successfully done"
        fi
      fi
    fi
        
  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "*** Now rebooting the phone ..."
      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}



# ----------------------------------------------------------------------
# task_execute_script 
#
# function: execute a script on the PC
#
# usage: task_execute_script  [reboot|reboot=no|reboot=yes] [ignorerc] [scriptname] [parameter_for_the_script]
#
# returns: ${__TRUE} - ok executing the task
#          ${__FALSE} - error executing the task
#
# Notes:
#
# - the name of the function must start with task_
# - the variable __FUNCTION must contain the function name
# - use ${PREFIX_FOR_THE_COMMANDS} for all commands that should not be executed in dry-run mode
# - add hints to fix the issues for this check to the local variable CUR_COMMAND_HINTS
# - use LogMsg to print messages
# - use LogErrorMsg to print error messages
# - use LogWarningMsg to print warning messages
# - use LogInfo to print messages that should only be printed if the parameter -v is used
#
function task_execute_script {
  typeset __FUNCTION="task_execute_script"
  typeset TASK_USAGE="${__FUNCTION} [reboot|noreboot|reboot=no|reboot=yes] [ignorerc] [scriptname] [parameter_for_the_script] "
  ${__DEBUG_CODE}
  ${__FUNCTION_INIT}

# init the return code of the function
#
  typeset THISRC=${__TRUE}

# set CONT to ${__FALSE} to not continue the task even if THISRC is ${__TRUE}
#
  typeset CONT=${__TRUE}

# add the hints to fix this issue (if any) to the variable CUR_COMMAND_HINTS
#
  typeset CUR_COMMAND_HINTS=""

# these are helper variables to execute OS commands (see the other checks for examples)
#
  typeset CUR_OUTPUT=""
  typeset TEMPRC=""

  typeset TMPFILE="${WORKDIR}/${__FUNCTION}_$$.sh"

  typeset PRINT_TASK_USAGE=${__FALSE}
  
# variables for parameter handling
#
  typeset CUR_TASK_PARAMETER=""

  typeset PARAMETER_KEY=""
  typeset PARAMETER_VAL=""


  typeset CMD_PARAMETER=""

  typeset CUR_SCRIPT=""
  
# ignore the return code of the task?
#
  typeset IGNORE_RC=${__FALSE}

# Reboot the phone after successfully executing the task?
#
# default is : no reboot
#
# Caution: this is a global variable!
#
  REBOOT="no"

# ---------------------------------------------------------------------
# check for task parameter
#
  while [ $# -ne 0 ] ; do
  
    CUR_TASK_PARAMETER="$1"
    shift

#
# split the parameter into key and value if possible
#
    PARAMETER_KEY="${CUR_TASK_PARAMETER%%=*}"
    PARAMETER_VAL="${CUR_TASK_PARAMETER#*=}"
    [ "${PARAMETER_KEY}"x = "${PARAMETER_VAL}"x ] && PARAMETER_VAL=""
    
    case ${CUR_TASK_PARAMETER} in

      ignorerc )
        IGNORE_RC=${__TRUE}
        ;;

      reboot | reboot=yes )
        REBOOT="yes"
        ;;
      
      reboot=no | noreboot )
        REBOOT="no"
        ;;
      
      * )    
        if [ -z ${CUR_SCRIPT} ] ; then
          CUR_SCRIPT="${CUR_TASK_PARAMETER}"
        else
          CMD_PARAMETER="${CMD_PARAMETER} ${CUR_TASK_PARAMETER}"
        fi
        ;;
                             
#          LogErrorMsg "Task ${__FUNCTION#task_*}: Unknown parameter found for the task \"${__FUNCTION#task_*}\" : \"${CUR_TASK_PARAMETER}\" "
#          PRINT_TASK_USAGE=${__TRUE}
#          THISRC=${__FALSE}
#          CONT=${__FALSE}

     esac
  done

  if [ "${CUR_SCRIPT}"x = ""x ] ; then
    LogErrorMsg "Task ${__FUNCTION#task_*}: Task parameter for the script to execute missing"
    PRINT_TASK_USAGE=${__TRUE}
    THISRC=${__FALSE}
    CONT=${__FALSE}
  fi
      
  if [ ${PRINT_TASK_USAGE} = ${__TRUE} ] ; then
    LogMsg "Task Usage: ${TASK_USAGE}"
  fi

# ---------------------------------------------------------------------
  
  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then

    CMD_PARAMETER="${CMD_PARAMETER} "
    
    LogMsg ""
    LogMsg "*** Executing the script  \"${CUR_SCRIPT}\" with the parameter \"${CMD_PARAMETER}\"  ..."
    LogMsg ""
    
    if [ "${REBOOT}"x = "yes"x ] ; then
      LogMsg "The automatic reboot after executing the script is enabled"
    else      
      LogMsg "The automatic reboot after executing the script is disabled"
    fi
    
    if [ ${IGNORE_RC} = ${__TRUE} ]; then
      LogMsg "The Returncode of the script is ignored"
      IGNORE_SCRIPT_RC=${__TRUE}
    else
      IGNORE_SCRIPT_RC=${__FALSE}
      LogMsg "The task execution stops if the script ends with a return code not zero"
    fi


    execute_script "${CUR_SCRIPT}" ${CMD_PARAMETER} 
    THISRC=$?
       

  fi

  if [ ${THISRC} = ${__TRUE} -a ${CONT} = ${__TRUE} ] ; then
    if [ "${REBOOT}"x = "yes"x ] ; then
      :

#      LogMsg "*** Now rebooting the phone ..."
#      reboot_phone wait force
    fi
  fi

# ---------------------------------------------------------------------

  if [ ${IGNORE_RC} = ${__TRUE} ]; then
    if [ ${THISRC} != ${__TRUE} ] ; then
      TASKS_EXECUTED_WITH_IGNORED_ERROR="${TASKS_EXECUTED_WITH_IGNORED_ERROR} ${__FUNCTION#task_*}"
      (( NO_TASKS_EXECUTED_WITH_IGNORED_ERROR = NO_TASKS_EXECUTED_WITH_IGNORED_ERROR + 1 ))

      LogMsg "Ignoring the return code of the task is requested via task parameter"
      THISRC=${__TRUE}
    fi
  fi

# ---------------------------------------------------------------------
# add the commands to fix this issue to the global list of commands (if any)
#
  if [ "${CUR_COMMAND_HINTS}"x != ""x ] ; then
    CUR_COMMAND_HINTS="### To fix the issues found in the function \"${__FUNCTION#task_*}\" do
#
${CUR_COMMAND_HINTS}"

    LogMsg "-"
    LogMsg "-" "${CUR_COMMAND_HINTS}"

    COMMAND_HINTS="${COMMAND_HINTS}
${CUR_COMMAND_HINTS}"
  fi

### remove the leading "#" from these lines to add this task
### to the list of tasks that should be checked manually
###
#  TASKS_TO_CHECK_MANUALLY="${TASKS_TO_CHECK_MANUALLY}
#  ${__FUNCTION#task_*} # see logs above"

  if [ ${THISRC} = ${__TRUE} ] ; then
    TASKS_SUCCESSFULLY_CHECKED="${TASKS_SUCCESSFULLY_CHECKED} ${__FUNCTION#task_*}"
  else
    TASKS_WITH_ERRORS="${TASKS_WITH_ERRORS} ${__FUNCTION#task_*}"
  fi

  return ${THISRC}
}
